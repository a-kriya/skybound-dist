var Ke=Object.defineProperty;var Je=(u,e,t)=>e in u?Ke(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t;var m=(u,e,t)=>Je(u,typeof e!="symbol"?e+"":e,t);import{V as w,Q as Qe,M as et,I as tt,L as st,F as it,C as $e,S as nt,G as ot,B as ve,a as B,b as de,c as be,P as ne,d as rt,e as Ee,f as ue,g as j,T as at,N as Le,h as me,D as H,i as J,j as qe,k as lt,O as ct,l as Te,E as W,m as _e,n as ht,o as Xe,p as ae,q as dt,r as Pe,s as ut,t as mt,W as pt,u as ft,v as gt,A as yt,w as wt}from"./three-BOd72dne.js";(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const n of i)if(n.type==="childList")for(const o of n.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&s(o)}).observe(document,{childList:!0,subtree:!0});function t(i){const n={};return i.integrity&&(n.integrity=i.integrity),i.referrerPolicy&&(n.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?n.credentials="include":i.crossOrigin==="anonymous"?n.credentials="omit":n.credentials="same-origin",n}function s(i){if(i.ep)return;i.ep=!0;const n=t(i);fetch(i.href,n)}})();var ee=function(){var u=0,e=document.createElement("div");e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(d){d.preventDefault(),s(++u%e.children.length)},!1);function t(d){return e.appendChild(d.dom),d}function s(d){for(var h=0;h<e.children.length;h++)e.children[h].style.display=h===d?"block":"none";u=d}var i=(performance||Date).now(),n=i,o=0,r=t(new ee.Panel("FPS","#0ff","#002")),l=t(new ee.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=t(new ee.Panel("MB","#f08","#201"));return s(0),{REVISION:16,dom:e,addPanel:t,showPanel:s,begin:function(){i=(performance||Date).now()},end:function(){o++;var d=(performance||Date).now();if(l.update(d-i,200),d>=n+1e3&&(r.update(o*1e3/(d-n),100),n=d,o=0,c)){var h=performance.memory;c.update(h.usedJSHeapSize/1048576,h.jsHeapSizeLimit/1048576)}return d},update:function(){i=this.end()},domElement:e,setMode:s}};ee.Panel=function(u,e,t){var s=1/0,i=0,n=Math.round,o=n(window.devicePixelRatio||1),r=80*o,l=48*o,c=3*o,d=2*o,h=3*o,a=15*o,f=74*o,y=30*o,g=document.createElement("canvas");g.width=r,g.height=l,g.style.cssText="width:80px;height:48px";var p=g.getContext("2d");return p.font="bold "+9*o+"px Helvetica,Arial,sans-serif",p.textBaseline="top",p.fillStyle=t,p.fillRect(0,0,r,l),p.fillStyle=e,p.fillText(u,c,d),p.fillRect(h,a,f,y),p.fillStyle=t,p.globalAlpha=.9,p.fillRect(h,a,f,y),{dom:g,update:function(P,M){s=Math.min(s,P),i=Math.max(i,P),p.fillStyle=t,p.globalAlpha=1,p.fillRect(0,0,r,a),p.fillStyle=e,p.fillText(n(P)+" "+u+" ("+n(s)+"-"+n(i)+")",c,d),p.drawImage(g,h+o,a,f-o,y,h,a,f-o,y),p.fillRect(h+f-o,a,o,y),p.fillStyle=t,p.globalAlpha=.9,p.fillRect(h+f-o,a,o,n((1-P/M)*y))}}};const Se=1e3,Ve=25,ce=1e4,F=100,vt=10,Pt=2.5,Ce=1e-4,Fe=1e-4,Ae=1e-4,pe=.99,xt=1e-4,Mt=8900331,bt=7566195,Et=6316128,Lt=3904470,Tt=14534787,_t=4749082,St=7773009,Vt=16777215,je=12892835,Re=8297810,Ct=3947580,Ie=16777184,Ft={lim0:{value:0,color:Tt},lim1:{value:10,color:_t},lim2:{value:100,color:St},lim3:{value:175,color:Vt}},ze=5,At=200,jt=200;function E(...u){if(u.length===1){const e=u[0];if(Array.isArray(e))return new w(...e);if(e instanceof w)return e}return u.length===3?new w(u[0],u[1],u[2]):new w}function U(u,e){const t=u instanceof w?u:new w(...u),s=e instanceof w?e:new w(...e),i=t.clone().add(s);return[i.x,i.y,i.z]}function xe(u){return[u.x,u.y,u.z]}function Rt(u){let e=u.toString(16);for(;e.length<6;)e=`0${e}`;const t=(s,i)=>parseInt(e.substring(s,i),16)/255;return[t(0,2),t(2,4),t(4,6)]}function It(u,e,t){const s=new Qe;return s.setFromEuler(e),new et().compose(u,s,t)}function zt(u,e){const t=new tt(u.geometry,u.material,e.length);t.castShadow=!0,t.receiveShadow=!0;for(let s=0;s<e.length;s++)t.setMatrixAt(s,e[s]);return t}function Ot(u,e,t,s,i,n){return u>=t&&u<=i&&e>=s&&e<=n}const Dt=/^[og]\s*(.+)?/,Bt=/^mtllib /,kt=/^usemtl /,Nt=/^usemap /,Oe=/\s+/,De=new w,fe=new w,Be=new w,ke=new w,A=new w,oe=new $e;function Gt(){const u={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(e,t){if(this.object&&this.object.fromDeclaration===!1){this.object.name=e,this.object.fromDeclaration=t!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:e||"",fromDeclaration:t!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(i,n){const o=this._finalize(!1);o&&(o.inherited||o.groupCount<=0)&&this.materials.splice(o.index,1);const r={index:this.materials.length,name:i||"",mtllib:Array.isArray(n)&&n.length>0?n[n.length-1]:"",smooth:o!==void 0?o.smooth:this.smooth,groupStart:o!==void 0?o.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(l){const c={index:typeof l=="number"?l:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return c.clone=this.clone.bind(c),c}};return this.materials.push(r),r},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(i){const n=this.currentMaterial();if(n&&n.groupEnd===-1&&(n.groupEnd=this.geometry.vertices.length/3,n.groupCount=n.groupEnd-n.groupStart,n.inherited=!1),i&&this.materials.length>1)for(let o=this.materials.length-1;o>=0;o--)this.materials[o].groupCount<=0&&this.materials.splice(o,1);return i&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),n}},s&&s.name&&typeof s.clone=="function"){const i=s.clone(0);i.inherited=!0,this.object.materials.push(i)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseNormalIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/3)*3},parseUVIndex:function(e,t){const s=parseInt(e,10);return(s>=0?s-1:s+t/2)*2},addVertex:function(e,t,s){const i=this.vertices,n=this.object.geometry.vertices;n.push(i[e+0],i[e+1],i[e+2]),n.push(i[t+0],i[t+1],i[t+2]),n.push(i[s+0],i[s+1],i[s+2])},addVertexPoint:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addVertexLine:function(e){const t=this.vertices;this.object.geometry.vertices.push(t[e+0],t[e+1],t[e+2])},addNormal:function(e,t,s){const i=this.normals,n=this.object.geometry.normals;n.push(i[e+0],i[e+1],i[e+2]),n.push(i[t+0],i[t+1],i[t+2]),n.push(i[s+0],i[s+1],i[s+2])},addFaceNormal:function(e,t,s){const i=this.vertices,n=this.object.geometry.normals;De.fromArray(i,e),fe.fromArray(i,t),Be.fromArray(i,s),A.subVectors(Be,fe),ke.subVectors(De,fe),A.cross(ke),A.normalize(),n.push(A.x,A.y,A.z),n.push(A.x,A.y,A.z),n.push(A.x,A.y,A.z)},addColor:function(e,t,s){const i=this.colors,n=this.object.geometry.colors;i[e]!==void 0&&n.push(i[e+0],i[e+1],i[e+2]),i[t]!==void 0&&n.push(i[t+0],i[t+1],i[t+2]),i[s]!==void 0&&n.push(i[s+0],i[s+1],i[s+2])},addUV:function(e,t,s){const i=this.uvs,n=this.object.geometry.uvs;n.push(i[e+0],i[e+1]),n.push(i[t+0],i[t+1]),n.push(i[s+0],i[s+1])},addDefaultUV:function(){const e=this.object.geometry.uvs;e.push(0,0),e.push(0,0),e.push(0,0)},addUVLine:function(e){const t=this.uvs;this.object.geometry.uvs.push(t[e+0],t[e+1])},addFace:function(e,t,s,i,n,o,r,l,c){const d=this.vertices.length;let h=this.parseVertexIndex(e,d),a=this.parseVertexIndex(t,d),f=this.parseVertexIndex(s,d);if(this.addVertex(h,a,f),this.addColor(h,a,f),r!==void 0&&r!==""){const y=this.normals.length;h=this.parseNormalIndex(r,y),a=this.parseNormalIndex(l,y),f=this.parseNormalIndex(c,y),this.addNormal(h,a,f)}else this.addFaceNormal(h,a,f);if(i!==void 0&&i!==""){const y=this.uvs.length;h=this.parseUVIndex(i,y),a=this.parseUVIndex(n,y),f=this.parseUVIndex(o,y),this.addUV(h,a,f),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(e){this.object.geometry.type="Points";const t=this.vertices.length;for(let s=0,i=e.length;s<i;s++){const n=this.parseVertexIndex(e[s],t);this.addVertexPoint(n),this.addColor(n)}},addLineGeometry:function(e,t){this.object.geometry.type="Line";const s=this.vertices.length,i=this.uvs.length;for(let n=0,o=e.length;n<o;n++)this.addVertexLine(this.parseVertexIndex(e[n],s));for(let n=0,o=t.length;n<o;n++)this.addUVLine(this.parseUVIndex(t[n],i))}};return u.startObject("",!1),u}class Ht extends st{constructor(e){super(e),this.materials=null}load(e,t,s,i){const n=this,o=new it(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(r){try{t(n.parse(r))}catch(l){i?i(l):console.error(l),n.manager.itemError(e)}},s,i)}setMaterials(e){return this.materials=e,this}parse(e){const t=new Gt;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const s=e.split(`
`);let i=[];for(let r=0,l=s.length;r<l;r++){const c=s[r].trimStart();if(c.length===0)continue;const d=c.charAt(0);if(d!=="#")if(d==="v"){const h=c.split(Oe);switch(h[0]){case"v":t.vertices.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3])),h.length>=7?(oe.setRGB(parseFloat(h[4]),parseFloat(h[5]),parseFloat(h[6]),nt),t.colors.push(oe.r,oe.g,oe.b)):t.colors.push(void 0,void 0,void 0);break;case"vn":t.normals.push(parseFloat(h[1]),parseFloat(h[2]),parseFloat(h[3]));break;case"vt":t.uvs.push(parseFloat(h[1]),parseFloat(h[2]));break}}else if(d==="f"){const a=c.slice(1).trim().split(Oe),f=[];for(let g=0,p=a.length;g<p;g++){const P=a[g];if(P.length>0){const M=P.split("/");f.push(M)}}const y=f[0];for(let g=1,p=f.length-1;g<p;g++){const P=f[g],M=f[g+1];t.addFace(y[0],P[0],M[0],y[1],P[1],M[1],y[2],P[2],M[2])}}else if(d==="l"){const h=c.substring(1).trim().split(" ");let a=[];const f=[];if(c.indexOf("/")===-1)a=h;else for(let y=0,g=h.length;y<g;y++){const p=h[y].split("/");p[0]!==""&&a.push(p[0]),p[1]!==""&&f.push(p[1])}t.addLineGeometry(a,f)}else if(d==="p"){const a=c.slice(1).trim().split(" ");t.addPointGeometry(a)}else if((i=Dt.exec(c))!==null){const h=(" "+i[0].slice(1).trim()).slice(1);t.startObject(h)}else if(kt.test(c))t.object.startMaterial(c.substring(7).trim(),t.materialLibraries);else if(Bt.test(c))t.materialLibraries.push(c.substring(7).trim());else if(Nt.test(c))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(d==="s"){if(i=c.split(" "),i.length>1){const a=i[1].trim().toLowerCase();t.object.smooth=a!=="0"&&a!=="off"}else t.object.smooth=!0;const h=t.object.currentMaterial();h&&(h.smooth=t.object.smooth)}else{if(c==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+c+'"')}}t.finalize();const n=new ot;if(n.materialLibraries=[].concat(t.materialLibraries),!(t.objects.length===1&&t.objects[0].geometry.vertices.length===0)===!0)for(let r=0,l=t.objects.length;r<l;r++){const c=t.objects[r],d=c.geometry,h=c.materials,a=d.type==="Line",f=d.type==="Points";let y=!1;if(d.vertices.length===0)continue;const g=new ve;g.setAttribute("position",new B(d.vertices,3)),d.normals.length>0&&g.setAttribute("normal",new B(d.normals,3)),d.colors.length>0&&(y=!0,g.setAttribute("color",new B(d.colors,3))),d.hasUVIndices===!0&&g.setAttribute("uv",new B(d.uvs,2));const p=[];for(let M=0,R=h.length;M<R;M++){const _=h[M],O=_.name+"_"+_.smooth+"_"+y;let x=t.materials[O];if(this.materials!==null){if(x=this.materials.create(_.name),a&&x&&!(x instanceof de)){const V=new de;be.prototype.copy.call(V,x),V.color.copy(x.color),x=V}else if(f&&x&&!(x instanceof ne)){const V=new ne({size:10,sizeAttenuation:!1});be.prototype.copy.call(V,x),V.color.copy(x.color),V.map=x.map,x=V}}x===void 0&&(a?x=new de:f?x=new ne({size:1,sizeAttenuation:!1}):x=new rt,x.name=_.name,x.flatShading=!_.smooth,x.vertexColors=y,t.materials[O]=x),p.push(x)}let P;if(p.length>1){for(let M=0,R=h.length;M<R;M++){const _=h[M];g.addGroup(_.groupStart,_.groupCount,M)}a?P=new Ee(g,p):f?P=new ue(g,p):P=new j(g,p)}else a?P=new Ee(g,p[0]):f?P=new ue(g,p[0]):P=new j(g,p[0]);P.name=c.name,n.add(P)}else if(t.vertices.length>0){const r=new ne({size:1,sizeAttenuation:!1}),l=new ve;l.setAttribute("position",new B(t.vertices,3)),t.colors.length>0&&t.colors[0]!==void 0&&(l.setAttribute("color",new B(t.colors,3)),r.vertexColors=!0);const c=new ue(l,r);n.add(c)}return n}}class Wt{constructor(){m(this,"objLoader");m(this,"threeTone");m(this,"planeMaterial");m(this,"terrainMaterial");m(this,"waterMaterial");m(this,"volcanoMaterial");m(this,"weaponMaterial");m(this,"standMaterial");m(this,"planeMesh");m(this,"volcanoBaseGeometry",null);m(this,"groupTree",[]);m(this,"groupPalm",[]);m(this,"weaponModel");this.objLoader=new Ht,this.threeTone=new at().load("/textures/fiveTone.jpg"),this.threeTone.minFilter=Le,this.threeTone.magFilter=Le,this.planeMaterial=new me({color:Et,side:H}),this.terrainMaterial=new J({vertexColors:!0,side:H,gradientMap:this.threeTone}),this.waterMaterial=new me({color:Lt,side:H,transparent:!0,opacity:.8}),this.volcanoMaterial=new J({color:Ct,side:H,gradientMap:this.threeTone}),this.weaponMaterial=new me({color:Ie,emissive:Ie}),this.standMaterial=new J({color:12566463,gradientMap:this.threeTone}),this.weaponModel=new j(new qe(.1,.1,2),this.weaponMaterial)}createPropMaterial(e){return new J({color:e,side:H,gradientMap:this.threeTone})}load(e,t,s){return new Promise((i,n)=>{this.objLoader.load(e,o=>{o.traverse(r=>{r instanceof j&&(r.material=t,r.geometry.computeVertexNormals(!0),r.castShadow=!0)}),o.scale.set(s,s,s),i(o)},o=>{`${e}`,o.loaded/o.total*100},o=>{console.error(`Error loading model from ${e}:`,o),n(new Error(`Failed to load OBJ model from ${e}`))})})}loadGeometry(e){return new Promise((t,s)=>{let i;this.objLoader.load(e,n=>{n.traverse(o=>{o instanceof j&&(o.geometry.computeVertexNormals(!0),i=o.geometry)}),i?t({path:e,geometry:i}):(console.error(`No geometry found in loaded mesh from ${e}`),s(new Error(`No geometry found in ${e}`)))},n=>{`${e}`,n.loaded/n.total*100},n=>{console.error(`Error loading geometry from ${e}:`,n),s(new Error(`Failed to load geometry from ${e}`))})})}async gLoad(e){const t=[],s=e.map(async n=>{try{const{geometry:o}=await this.loadGeometry(n.path),r=this.createPropMaterial(n.color);return new j(o,r)}catch(o){return console.error(`Failed to load geometry for gLoad: ${n.path}`,o),null}});return(await Promise.all(s)).forEach(n=>{n&&t.push(n)}),t}async loadAllAssets(){try{const e=await this.load("/models/vehicle/airplane.obj",this.planeMaterial,.1);this.planeMesh=e;const t=await this.loadGeometry("/models/maps/volcano_base.obj");this.volcanoBaseGeometry=t.geometry;const s=[this.gLoad([{path:"/models/tree/tree_trunk.obj",color:je},{path:"/models/tree/tree_leaves.obj",color:Re}]),this.gLoad([{path:"/models/palm_tree/trunk.obj",color:je},{path:"/models/palm_tree/leaves.obj",color:Re}])],[i,n]=await Promise.all(s);this.groupTree=i,this.groupPalm=n}catch(e){throw console.error("Error loading assets in AssetManager:",e),e}}}const{lerp:N}=lt,T=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let u=0;u<256;u++)T[256+u]=T[u];function ge(u){return u*u*u*(u*(u*6-15)+10)}function D(u,e,t,s){const i=u&15,n=i<8?e:t,o=i<4?t:i==12||i==14?e:s;return((i&1)==0?n:-n)+((i&2)==0?o:-o)}class Ut{noise(e,t,s){const i=Math.floor(e),n=Math.floor(t),o=Math.floor(s),r=i&255,l=n&255,c=o&255;e-=i,t-=n,s-=o;const d=e-1,h=t-1,a=s-1,f=ge(e),y=ge(t),g=ge(s),p=T[r]+l,P=T[p]+c,M=T[p+1]+c,R=T[r+1]+l,_=T[R]+c,O=T[R+1]+c;return N(N(N(D(T[P],e,t,s),D(T[_],d,t,s),f),N(D(T[M],e,h,s),D(T[O],d,h,s),f),y),N(N(D(T[P+1],e,t,a),D(T[_+1],d,t,a),f),N(D(T[M+1],e,h,a),D(T[O+1],d,h,a),f),y),g)}}const se=class se{constructor(e){m(this,"assetManager");m(this,"terrainObject3D");m(this,"waterMesh");m(this,"waterLevel",-10);m(this,"populations",[]);m(this,"planeStep",{x:0,z:0});m(this,"prevPlaneStep",{x:Math.PI,z:Math.PI});this.assetManager=e,this.terrainObject3D=new ct,this.terrainObject3D.position.y=-10,this.waterMesh=new j(new Te(ce,ce,1e3,1e3),this.assetManager.waterMaterial),this.waterMesh.rotation.x=Math.PI/2}getTerrainObject3D(){return this.terrainObject3D}getWaterMesh(){return this.waterMesh}initializeInternalPopulations(){this.populations=[{group:this.assetManager.groupTree,rarity:.02,min:10,max:150,seed:1e3,scale:.5,offset:3,randRot:()=>new W(Math.random()*.2,Math.random()*Math.PI*2,Math.random()*.2)},{group:this.assetManager.groupPalm,rarity:.01,min:0,max:40,seed:1e3,scale:.5,offset:0,randRot:()=>new W(Math.random()*.2,Math.random()*Math.PI*2,Math.random()*.2)}]}handleTerrainGeneration(e){this.waterMesh.position.set(0,this.waterLevel,0),this.planeStep={x:Math.round(e.x/F),z:Math.round(e.z/F)};const t=-Math.floor(Se/F),s=Math.ceil(Se/F);if(this.planeStep.x!==this.prevPlaneStep.x||this.planeStep.z!==this.prevPlaneStep.z){const i=[t+this.planeStep.x,t+this.planeStep.z,s+this.planeStep.x,s+this.planeStep.z];this.removeTerrainBounds(...i),this.fillTerrainBounds(...i)}this.prevPlaneStep={...this.planeStep}}checkTerrainCollision(e){if(this.waterLevel>e.min.y)return!0;let t;for(const s of this.terrainObject3D.children){const i=s.position.clone().divideScalar(F);if(i.x===this.planeStep.x&&i.z===this.planeStep.z){t=s;break}}return t?this.collisionCheckDetail(t,e,0):!1}noise(e,t){return se.perlin.noise(e.x,e.y,0)*t}terrainNoise(e,t,s){return this.noise(e.divideScalar(t),vt*s)}noiseFunction(e){return this.terrainNoise(e,1,1)+this.terrainNoise(e,10,10)+this.terrainNoise(e,100,50)-5}applyTerrainNoise(e,t){const s=e.geometry.attributes.position,i=e.geometry.attributes.uv,n=new _e;for(let o=0;o<s.count;o++){n.fromBufferAttribute(i,o).add(t).multiplyScalar(Pt);const r=this.noiseFunction(n);s.setZ(o,r)}s.needsUpdate=!0}applyTerrainShader(e,t){const s=r=>{const[l,c,d]=Rt(r);return`vec3(${l}, ${c}, ${d})`},i="varying vec3 vPos;",n=`
      uniform float lim0;
      uniform float lim1;
      uniform float lim2;
      uniform float lim3;
      ${i}
    `,o=`
      vec3 col = vPos.y >= lim3 ? ${s(t.lim3.color)} :
                  vPos.y >= lim2 ? ${s(t.lim2.color)} :
                  vPos.y >= lim1 ? ${s(t.lim1.color)} :
                                  ${s(t.lim0.color)};
      vec4 diffuseColor = vec4(col, opacity);
    `;e.material=new J({side:H}),e.material.onBeforeCompile=r=>{Object.assign(r.uniforms,{lim0:t.lim0,lim1:t.lim1,lim2:t.lim2,lim3:t.lim3}),r.vertexShader=`
        ${i}
        ${r.vertexShader.replace("#include <begin_vertex>",`#include <begin_vertex>
vPos = vec3(position);`)}
      `,r.fragmentShader=`
        ${n}
        ${r.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );",o)}
      `}}addTerrain(e,t){const s=new Te(F,F,Ve,Ve),i=new j(s,this.assetManager.terrainMaterial);i.receiveShadow=!0,this.applyTerrainNoise(i,new _e(e,t)),s.rotateX(Math.PI/2),i.position.set(e,0,t).multiplyScalar(F),s.computeVertexNormals(),this.terrainObject3D.add(i),this.applyTerrainShader(i,Ft),this.populateTerrain(i)}populateTerrain(e){for(const t of this.populations)this.populateGroupMesh(e,t)}populateGroupMesh(e,t){const s=e.geometry.attributes.position,i=[];for(let n=0;n<s.count;n++)if(Math.random()>1-t.rarity){const o=new w;if(o.fromBufferAttribute(s,n),o.y+=t.offset,o.y-t.offset>t.min&&o.y<t.max&&se.perlin.noise(o.x/F+t.seed,o.z/F+t.seed,0)>=-.1){const r=t.randRot(),l=Math.random()/2+.5,c=E(l,l,l).multiplyScalar(t.scale);i.push(It(o,r,c))}}for(const n of t.group)e.add(zt(n,i))}fillTerrainBounds(e,t,s,i){for(let n=e;n<=s;n++)for(let o=t;o<=i;o++)this.existsTerrain(n,o)||this.addTerrain(n,o)}existsTerrain(e,t){for(const s of this.terrainObject3D.children){const i=s.position.clone().divideScalar(F);if(i.x===e&&i.z===t)return!0}return!1}removeTerrainBounds(e,t,s,i){const n=[];for(const o of this.terrainObject3D.children){const r=o.position.clone().divideScalar(F);(r.x<e||r.x>s||r.z<t||r.z>i)&&n.push(o)}for(const o of n)this.terrainObject3D.remove(o)}collisionCheckDetail(e,t,s){const i=e.geometry.attributes.position;for(let n=0;n<i.count;n++){const o=new w;if(o.fromBufferAttribute(i,n),e.localToWorld(o),o.y>t.min.y&&Ot(o.x,o.z,t.min.x-s,t.min.z-s,t.max.x+s,t.max.z+s))return!0}return!1}};m(se,"perlin",new Ut);let Me=se;class $t{constructor(e,t){m(this,"camera");m(this,"baseLocalPos",E(0,10,20));m(this,"baseLocalRot",new W(0,0,0));m(this,"save",E(0,10,20));m(this,"factor",500);this.camera=new ht(75,e/t,.1,1e4),this.camera.position.copy(this.baseLocalPos),this.camera.rotation.copy(this.baseLocalRot)}getThreeCamera(){return this.camera}handleResize(e,t){this.camera.aspect=e/t,this.camera.updateProjectionMatrix()}updateSavePosition(){this.save=this.camera.position.clone()}getBaseLocalPosition(){return this.baseLocalPos}setPosition(e){this.camera.position.copy(e)}setRotation(e){this.camera.rotation.copy(e)}update(e,t){const s=E(-e.rotVel.yaw*this.factor,e.rotVel.pitch*this.factor,-e.vel.local.z/10*this.factor);if(this.camera.position.set(...U(this.baseLocalPos,s)),this.camera.rotation.copy(this.baseLocalRot),t){const i=e.getPosition();t.target.position.copy(i),t.position.set(i.x+1,i.y+1,i.z+1)}}updateStatic(e){this.camera.position.set(...U(this.save,E(-e.x/4e3,e.y/4e3,0)))}}var Q=(u=>(u[u.DOGFIGHT=0]="DOGFIGHT",u[u.FREEFLIGHT=1]="FREEFLIGHT",u))(Q||{});class qt{constructor(){m(this,"_inputState");this._inputState={keys:{},mouse:{x:0,y:0}}}_updateKey(e,t){this._inputState.keys[e]=t}_updateMousePosition(e,t){this._inputState.mouse.x=e,this._inputState.mouse.y=t}keyPressed(e){return this._inputState.keys.hasOwnProperty(e)?this._inputState.keys[e]:!1}handlePlaneKeys(e){if(!e)return;let t=e.rotVel;this.keyPressed("ArrowUp")&&(t.pitch+=Fe),this.keyPressed("ArrowDown")&&(t.pitch-=Fe),this.keyPressed("ArrowLeft")&&(t.yaw+=Ce),this.keyPressed("ArrowRight")&&(t.yaw-=Ce),this.keyPressed("a")&&(t.roll+=Ae),this.keyPressed("d")&&(t.roll-=Ae),e.rotVel=t,this.keyPressed("w")?e.thrust=xt:this.keyPressed("s")?e.thrust=-1e-4:e.thrust=0}setupGlobalInputListeners(){const e=s=>{this._updateKey(s.key,s.type==="keydown")};document.removeEventListener("keydown",e),document.removeEventListener("keyup",e),document.addEventListener("keydown",e),document.addEventListener("keyup",e);const t=s=>{this._updateMousePosition(s.clientX,s.clientY)};document.removeEventListener("mousemove",t),document.addEventListener("mousemove",t)}getInputState(){return this._inputState}}const le=0,Xt=1,Yt=new w,Ne=new Xe,ye=new ae,Ge=new w,re=new dt;class Zt{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new He,this.unassigned=new He,this.vertices=[]}setFromPoints(e){if(e.length>=4){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.vertices.push(new Kt(e[t]));this._compute()}return this}setFromObject(e){const t=[];return e.updateMatrixWorld(!0),e.traverse(function(s){const i=s.geometry;if(i!==void 0){const n=i.attributes.position;if(n!==void 0)for(let o=0,r=n.count;o<r;o++){const l=new w;l.fromBufferAttribute(n,o).applyMatrix4(s.matrixWorld),t.push(l)}}}),this.setFromPoints(t)}containsPoint(e){const t=this.faces;for(let s=0,i=t.length;s<i;s++)if(t[s].distanceToPoint(e)>this.tolerance)return!1;return!0}intersectRay(e,t){const s=this.faces;let i=-1/0,n=1/0;for(let o=0,r=s.length;o<r;o++){const l=s[o],c=l.distanceToPoint(e.origin),d=l.normal.dot(e.direction);if(c>0&&d>=0)return null;const h=d!==0?-c/d:0;if(!(h<=0)&&(d>0?n=Math.min(h,n):i=Math.max(h,i),i>n))return null}return i!==-1/0?e.at(i,t):e.at(n,t),t}intersectsRay(e){return this.intersectRay(e,Yt)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}_addVertexToFace(e,t){return e.face=t,t.outside===null?this.assigned.append(e):this.assigned.insertBefore(t.outside,e),t.outside=e,this}_removeVertexFromFace(e,t){return e===t.outside&&(e.next!==null&&e.next.face===t?t.outside=e.next:t.outside=null),this.assigned.remove(e),this}_removeAllVerticesFromFace(e){if(e.outside!==null){const t=e.outside;let s=e.outside;for(;s.next!==null&&s.next.face===e;)s=s.next;return this.assigned.removeSubList(t,s),t.prev=s.next=null,e.outside=null,t}}_deleteFaceVertices(e,t){const s=this._removeAllVerticesFromFace(e);if(s!==void 0)if(t===void 0)this.unassigned.appendChain(s);else{let i=s;do{const n=i.next;t.distanceToPoint(i.point)>this.tolerance?this._addVertexToFace(i,t):this.unassigned.append(i),i=n}while(i!==null)}return this}_resolveUnassignedPoints(e){if(this.unassigned.isEmpty()===!1){let t=this.unassigned.first();do{const s=t.next;let i=this.tolerance,n=null;for(let o=0;o<e.length;o++){const r=e[o];if(r.mark===le){const l=r.distanceToPoint(t.point);if(l>i&&(i=l,n=r),i>1e3*this.tolerance)break}}n!==null&&this._addVertexToFace(t,n),t=s}while(t!==null)}return this}_computeExtremes(){const e=new w,t=new w,s=[],i=[];for(let n=0;n<3;n++)s[n]=i[n]=this.vertices[0];e.copy(this.vertices[0].point),t.copy(this.vertices[0].point);for(let n=0,o=this.vertices.length;n<o;n++){const r=this.vertices[n],l=r.point;for(let c=0;c<3;c++)l.getComponent(c)<e.getComponent(c)&&(e.setComponent(c,l.getComponent(c)),s[c]=r);for(let c=0;c<3;c++)l.getComponent(c)>t.getComponent(c)&&(t.setComponent(c,l.getComponent(c)),i[c]=r)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(e.x),Math.abs(t.x))+Math.max(Math.abs(e.y),Math.abs(t.y))+Math.max(Math.abs(e.z),Math.abs(t.z))),{min:s,max:i}}_computeInitialHull(){const e=this.vertices,t=this._computeExtremes(),s=t.min,i=t.max;let n=0,o=0;for(let a=0;a<3;a++){const f=i[a].point.getComponent(a)-s[a].point.getComponent(a);f>n&&(n=f,o=a)}const r=s[o],l=i[o];let c,d;n=0,Ne.set(r.point,l.point);for(let a=0,f=this.vertices.length;a<f;a++){const y=e[a];if(y!==r&&y!==l){Ne.closestPointToPoint(y.point,!0,Ge);const g=Ge.distanceToSquared(y.point);g>n&&(n=g,c=y)}}n=-1,ye.setFromCoplanarPoints(r.point,l.point,c.point);for(let a=0,f=this.vertices.length;a<f;a++){const y=e[a];if(y!==r&&y!==l&&y!==c){const g=Math.abs(ye.distanceToPoint(y.point));g>n&&(n=g,d=y)}}const h=[];if(ye.distanceToPoint(d.point)<0){h.push(I.create(r,l,c),I.create(d,l,r),I.create(d,c,l),I.create(d,r,c));for(let a=0;a<3;a++){const f=(a+1)%3;h[a+1].getEdge(2).setTwin(h[0].getEdge(f)),h[a+1].getEdge(1).setTwin(h[f+1].getEdge(0))}}else{h.push(I.create(r,c,l),I.create(d,r,l),I.create(d,l,c),I.create(d,c,r));for(let a=0;a<3;a++){const f=(a+1)%3;h[a+1].getEdge(2).setTwin(h[0].getEdge((3-a)%3)),h[a+1].getEdge(0).setTwin(h[f+1].getEdge(1))}}for(let a=0;a<4;a++)this.faces.push(h[a]);for(let a=0,f=e.length;a<f;a++){const y=e[a];if(y!==r&&y!==l&&y!==c&&y!==d){n=this.tolerance;let g=null;for(let p=0;p<4;p++){const P=this.faces[p].distanceToPoint(y.point);P>n&&(n=P,g=this.faces[p])}g!==null&&this._addVertexToFace(y,g)}}return this}_reindexFaces(){const e=[];for(let t=0;t<this.faces.length;t++){const s=this.faces[t];s.mark===le&&e.push(s)}return this.faces=e,this}_nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let e,t=0;const s=this.assigned.first().face;let i=s.outside;do{const n=s.distanceToPoint(i.point);n>t&&(t=n,e=i),i=i.next}while(i!==null&&i.face===s);return e}}_computeHorizon(e,t,s,i){this._deleteFaceVertices(s),s.mark=Xt;let n;t===null?n=t=s.getEdge(0):n=t.next;do{const o=n.twin,r=o.face;r.mark===le&&(r.distanceToPoint(e)>this.tolerance?this._computeHorizon(e,o,r,i):i.push(n)),n=n.next}while(n!==t);return this}_addAdjoiningFace(e,t){const s=I.create(e,t.tail(),t.head());return this.faces.push(s),s.getEdge(-1).setTwin(t.twin),s.getEdge(0)}_addNewFaces(e,t){this.newFaces=[];let s=null,i=null;for(let n=0;n<t.length;n++){const o=t[n],r=this._addAdjoiningFace(e,o);s===null?s=r:r.next.setTwin(i),this.newFaces.push(r.face),i=r}return s.next.setTwin(i),this}_addVertexToHull(e){const t=[];return this.unassigned.clear(),this._removeVertexFromFace(e,e.face),this._computeHorizon(e.point,null,e.face,t),this._addNewFaces(e,t),this._resolveUnassignedPoints(this.newFaces),this}_cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}_compute(){let e;for(this._computeInitialHull();(e=this._nextVertexToAdd())!==void 0;)this._addVertexToHull(e);return this._reindexFaces(),this._cleanup(),this}}class I{constructor(){this.normal=new w,this.midpoint=new w,this.area=0,this.constant=0,this.outside=null,this.mark=le,this.edge=null}static create(e,t,s){const i=new I,n=new we(e,i),o=new we(t,i),r=new we(s,i);return n.next=r.prev=o,o.next=n.prev=r,r.next=o.prev=n,i.edge=n,i.compute()}getEdge(e){let t=this.edge;for(;e>0;)t=t.next,e--;for(;e<0;)t=t.prev,e++;return t}compute(){const e=this.edge.tail(),t=this.edge.head(),s=this.edge.next.head();return re.set(e.point,t.point,s.point),re.getNormal(this.normal),re.getMidpoint(this.midpoint),this.area=re.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(e){return this.normal.dot(e)-this.constant}}class we{constructor(e,t){this.vertex=e,this.prev=null,this.next=null,this.twin=null,this.face=t}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceTo(e.point):-1}lengthSquared(){const e=this.head(),t=this.tail();return t!==null?t.point.distanceToSquared(e.point):-1}setTwin(e){return this.twin=e,e.twin=this,this}}class Kt{constructor(e){this.point=e,this.prev=null,this.next=null,this.face=null}}class He{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(e,t){return t.prev=e.prev,t.next=e,t.prev===null?this.head=t:t.prev.next=t,e.prev=t,this}insertAfter(e,t){return t.prev=e,t.next=e.next,t.next===null?this.tail=t:t.next.prev=t,e.next=t,this}append(e){return this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail,e.next=null,this.tail=e,this}appendChain(e){for(this.head===null?this.head=e:this.tail.next=e,e.prev=this.tail;e.next!==null;)e=e.next;return this.tail=e,this}remove(e){return e.prev===null?this.head=e.next:e.prev.next=e.next,e.next===null?this.tail=e.prev:e.next.prev=e.prev,this}removeSubList(e,t){return e.prev===null?this.head=t.next:e.prev.next=t.next,t.next===null?this.tail=e.prev:t.next.prev=e.prev,this}isEmpty(){return this.head===null}}class We extends ve{constructor(e=[]){super();const t=[],s=[],n=new Zt().setFromPoints(e).faces;for(let o=0;o<n.length;o++){const r=n[o];let l=r.edge;do{const c=l.head().point;t.push(c.x,c.y,c.z),s.push(r.normal.x,r.normal.y,r.normal.z),l=l.next}while(l!==r.edge)}this.setAttribute("position",new B(t,3)),this.setAttribute("normal",new B(s,3))}}const Jt=new w;class te{constructor(e=1.4,t=1e-4){this.minSizeForBreak=e,this.smallDelta=t,this.tempLine1=new Xe,this.tempPlane1=new ae,this.tempPlane2=new ae,this.tempPlane_Cut=new ae,this.tempCM1=new w,this.tempCM2=new w,this.tempVector3=new w,this.tempVector3_2=new w,this.tempVector3_3=new w,this.tempVector3_P0=new w,this.tempVector3_P1=new w,this.tempVector3_P2=new w,this.tempVector3_N0=new w,this.tempVector3_N1=new w,this.tempVector3_AB=new w,this.tempVector3_CB=new w,this.tempResultObjects={object1:null,object2:null},this.segments=[];const s=30*30;for(let i=0;i<s;i++)this.segments[i]=!1}prepareBreakableObject(e,t,s,i,n){const o=e.userData;o.mass=t,o.velocity=s.clone(),o.angularVelocity=i.clone(),o.breakable=n}subdivideByImpact(e,t,s,i,n){const o=[],r=this.tempPlane1,l=this.tempPlane2;this.tempVector3.addVectors(t,s),r.setFromCoplanarPoints(t,e.position,this.tempVector3);const c=n+i,d=this;function h(a,f,y,g){if(Math.random()<g*.05||g>c){o.push(a);return}let p=Math.PI;g===0?(l.normal.copy(r.normal),l.constant=r.constant):g<=i?(p=(y-f)*(.2+.6*Math.random())+f,d.tempVector3_2.copy(e.position).sub(t).applyAxisAngle(s,p).add(t),l.setFromCoplanarPoints(t,d.tempVector3,d.tempVector3_2)):(p=(.5*(g&1)+.2*(2-Math.random()))*Math.PI,d.tempVector3_2.copy(t).sub(a.position).applyAxisAngle(s,p).add(a.position),d.tempVector3_3.copy(s).add(a.position),l.setFromCoplanarPoints(a.position,d.tempVector3_3,d.tempVector3_2)),d.cutByPlane(a,l,d.tempResultObjects);const P=d.tempResultObjects.object1,M=d.tempResultObjects.object2;P&&h(P,f,p,g+1),M&&h(M,p,y,g+1)}return h(e,0,2*Math.PI,0),o}cutByPlane(e,t,s){const i=e.geometry,n=i.attributes.position.array,o=i.attributes.normal.array,r=n.length/3;let l=r/3,c=i.getIndex();c&&(c=c.array,l=c.length/3);function d(v,b){const L=v*3+b;return c?c[L]:L}const h=[],a=[],f=this.smallDelta,y=r*r;for(let v=0;v<y;v++)this.segments[v]=!1;const g=this.tempVector3_P0,p=this.tempVector3_P1,P=this.tempVector3_N0,M=this.tempVector3_N1;for(let v=0;v<l-1;v++){const b=d(v,0),L=d(v,1),k=d(v,2);P.set(o[b],o[b]+1,o[b]+2);for(let C=v+1;C<l;C++){const S=d(C,0),z=d(C,1),ie=d(C,2);M.set(o[S],o[S]+1,o[S]+2),1-P.dot(M)<f&&(b===S||b===z||b===ie?L===S||L===z||L===ie?(this.segments[b*r+L]=!0,this.segments[L*r+b]=!0):(this.segments[k*r+b]=!0,this.segments[b*r+k]=!0):(L===S||L===z||L===ie)&&(this.segments[k*r+L]=!0,this.segments[L*r+k]=!0))}}const R=this.tempPlane_Cut;e.updateMatrix(),te.transformPlaneToLocalSpace(t,e.matrix,R);for(let v=0;v<l;v++){const b=d(v,0),L=d(v,1),k=d(v,2);for(let C=0;C<3;C++){const S=C===0?b:C===1?L:k,z=C===0?L:C===1?k:b;if(this.segments[S*r+z])continue;this.segments[S*r+z]=!0,this.segments[z*r+S]=!0,g.set(n[3*S],n[3*S+1],n[3*S+2]),p.set(n[3*z],n[3*z+1],n[3*z+2]);let G=0,Y=R.distanceToPoint(g);Y>f?(G=2,a.push(g.clone())):Y<-f?(G=1,h.push(g.clone())):(G=3,h.push(g.clone()),a.push(g.clone()));let Z=0;if(Y=R.distanceToPoint(p),Y>f?(Z=2,a.push(p.clone())):Y<-f?(Z=1,h.push(p.clone())):(Z=3,h.push(p.clone()),a.push(p.clone())),G===1&&Z===2||G===2&&Z===1){this.tempLine1.start.copy(g),this.tempLine1.end.copy(p);let K=new w;if(K=R.intersectLine(this.tempLine1,K),K===null)return console.error("Internal error: segment does not intersect plane."),s.segmentedObject1=null,s.segmentedObject2=null,0;h.push(K),a.push(K.clone())}}}const _=e.userData.mass*.5;this.tempCM1.set(0,0,0);let O=0;const x=h.length;if(x>0){for(let v=0;v<x;v++)this.tempCM1.add(h[v]);this.tempCM1.divideScalar(x);for(let v=0;v<x;v++){const b=h[v];b.sub(this.tempCM1),O=Math.max(O,b.x,b.y,b.z)}this.tempCM1.add(e.position)}this.tempCM2.set(0,0,0);let V=0;const $=a.length;if($>0){for(let v=0;v<$;v++)this.tempCM2.add(a[v]);this.tempCM2.divideScalar($);for(let v=0;v<$;v++){const b=a[v];b.sub(this.tempCM2),V=Math.max(V,b.x,b.y,b.z)}this.tempCM2.add(e.position)}let q=null,X=null,he=0;return x>4&&(q=new j(new We(h),e.material),q.position.copy(this.tempCM1),q.quaternion.copy(e.quaternion),this.prepareBreakableObject(q,_,e.userData.velocity,e.userData.angularVelocity,2*O>this.minSizeForBreak),he++),$>4&&(X=new j(new We(a),e.material),X.position.copy(this.tempCM2),X.quaternion.copy(e.quaternion),this.prepareBreakableObject(X,_,e.userData.velocity,e.userData.angularVelocity,2*V>this.minSizeForBreak),he++),s.object1=q,s.object2=X,he}static transformFreeVector(e,t){const s=e.x,i=e.y,n=e.z,o=t.elements;return e.x=o[0]*s+o[4]*i+o[8]*n,e.y=o[1]*s+o[5]*i+o[9]*n,e.z=o[2]*s+o[6]*i+o[10]*n,e}static transformFreeVectorInverse(e,t){const s=e.x,i=e.y,n=e.z,o=t.elements;return e.x=o[0]*s+o[1]*i+o[2]*n,e.y=o[4]*s+o[5]*i+o[6]*n,e.z=o[8]*s+o[9]*i+o[10]*n,e}static transformTiedVectorInverse(e,t){const s=e.x,i=e.y,n=e.z,o=t.elements;return e.x=o[0]*s+o[1]*i+o[2]*n-o[12],e.y=o[4]*s+o[5]*i+o[6]*n-o[13],e.z=o[8]*s+o[9]*i+o[10]*n-o[14],e}static transformPlaneToLocalSpace(e,t,s){s.normal.copy(e.normal),s.constant=e.constant;const i=te.transformTiedVectorInverse(e.coplanarPoint(Jt),t);te.transformFreeVectorInverse(s.normal,t),s.constant=-i.dot(s.normal)}}const Ye=new te;function Qt(u,e,t,s,i,n){const o=new Pe().setFromObject(u);!n.crashed&&i.checkTerrainCollision(o)&&Ze(u,e,t,s,!0,n);for(let r=n.shards.length-1;r>=0;r--){const l=n.shards[r];l.gVel-=.001,l.rotateX(l.cDir.x),l.rotateY(l.cDir.y),l.rotateZ(l.cDir.z),l.cDir.x*=.995,l.cDir.y*=.995,l.cDir.z*=.995,l.position.x+=l.cVel.x,l.position.y+=l.cVel.y+l.gVel,l.position.z+=l.cVel.z,l.time++,l.time>500&&(t.remove(l),n.shards.splice(r,1))}}function Ze(u,e,t,s,i,n){if(n.crashed)return;const o=E(1,.5,1),r=E(0,100,0),l=Ye.subdivideByImpact(e,o,r,1,5),c=()=>Math.random()*.1,d=()=>Math.random()*.5;n.clearShards();for(let h of l){const a=h;e.updateWorldMatrix(!0,!1),a.position.set(...xe(e.localToWorld(e.position.clone()))),t.add(a),a.cDir=E(c(),c(),c()),a.cVel=E(d(),d(),d()),a.gVel=.01,a.time=0,n.addShard(a)}n.shards.length>0&&(n.shards[0].cVel.y=.3),t.remove(u),n.setCrashed(!0),n.shards.length>0&&(s.position.set(0,0,0),n.shards[0].add(s)),setTimeout(()=>{document.getElementById("blackout").classList.remove("left"),document.getElementById("blackout").classList.remove("right"),setTimeout(()=>window.location.replace("/flight_ended.html"),1500)},3e3)}const es=500;class Ue{constructor(e,t){m(this,"mesh");m(this,"owner");this.mesh=e,this.owner=t}updateMovement(){this.mesh.translateZ(-2)}isOutOfBounds(e){return this.mesh.position.distanceTo(e)>es}getBoundingBox(){return new Pe().setFromObject(this.mesh)}checkCollisionWith(e){if(this.owner===e)return!1;const t=new Pe().setFromObject(e);return this.getBoundingBox().intersectsBox(t)}removeFromScene(e){e.remove(this.mesh)}}class ts{constructor(e,t){m(this,"mesh");m(this,"collider");m(this,"assetManager");m(this,"ammo",jt);m(this,"lastWeaponFireTime",0);m(this,"thrust",1e-4);m(this,"vel",{global:E(0,0,0),local:E(0,0,0)});m(this,"rot",{yaw:0,roll:0,pitch:0});m(this,"rotVel",{yaw:0,roll:0,pitch:0});this.mesh=e,this.assetManager=t,this.lastWeaponFireTime=0,this.collider=new j(new qe(10,1,20),this.assetManager.planeMaterial),this.collider.visible=!1,this.mesh.add(this.collider)}getAmmo(){return this.ammo}canFire(){return(performance.now()-this.lastWeaponFireTime>At||this.lastWeaponFireTime===0)&&this.ammo>0}fire(e,t){if(!this.canFire())return[];this.ammo--,this.lastWeaponFireTime=performance.now();const s=r=>{const l=E(U(t.clone().multiplyScalar(-1),E(r,2,-10)));return this.mesh.localToWorld(l.clone())},i=[],n=this.assetManager.weaponModel.clone();n.position.set(...xe(s(-10))),n.rotation.copy(this.mesh.rotation),e.add(n),i.push(new Ue(n,this.mesh));const o=this.assetManager.weaponModel.clone();return o.position.set(...xe(s(10))),o.rotation.copy(this.mesh.rotation),e.add(o),i.push(new Ue(o,this.mesh)),i}updatePhysics(){this.mesh.position.add(this.vel.global),this.mesh.translateX(this.vel.local.x),this.mesh.translateY(this.vel.local.y),this.mesh.translateZ(this.vel.local.z);let e=this.vel.local.z-this.thrust;e>0&&(e=0),this.vel.local.z=e;const t=this.vel.local.z<0?1e-6/-this.vel.local.z:1e-5;this.vel.global.y-=t,this.rotVel.pitch*=pe,this.rotVel.roll*=pe,this.rotVel.yaw*=pe,this.rot.pitch+=this.rotVel.pitch,this.rot.roll+=this.rotVel.roll,this.rot.yaw+=this.rotVel.yaw,this.mesh.rotateX(this.rotVel.pitch),this.mesh.rotateZ(this.rotVel.roll),this.mesh.rotateY(this.rotVel.yaw)}updateCollisions(){}getPosition(){return this.mesh.position.clone()}getRotation(){return this.mesh.rotation.clone()}setPosition(e){this.mesh.position.copy(e)}setRotation(e){this.mesh.rotation.copy(e)}}class ss{constructor(){m(this,"assetManager");m(this,"inputManager");m(this,"cameraManager");m(this,"terrainManager");m(this,"playerPlane");m(this,"stand");m(this,"activeProjectiles",[]);m(this,"shards",[]);m(this,"flying",!1);m(this,"mode",Q.DOGFIGHT);m(this,"players",[]);m(this,"prev",-1);m(this,"crashed",!1);m(this,"scene");m(this,"renderer");m(this,"dirLight");m(this,"stats");m(this,"ammoCountEl",document.getElementById("ammo-count"));m(this,"menuEl",document.getElementById("menu"));m(this,"blackoutEl",document.getElementById("blackout"));m(this,"loadingEl",document.getElementById("loading"));m(this,"waitingEl",document.getElementById("waiting"));m(this,"ammoEl",document.getElementById("ammo"));m(this,"freeButtonEl",document.getElementById("freeflight"));m(this,"headingEl",document.getElementsByClassName("heading")[0]);m(this,"selectEl",document.getElementsByClassName("select")[0]);m(this,"onWindowResize",()=>{const e=window.innerWidth,t=window.innerHeight;this.renderer.setSize(e,t),this.cameraManager.handleResize(e,t)});m(this,"animate",()=>{if(this.stats.begin(),requestAnimationFrame(this.animate),this.flying){this.prev<0&&(this.prev=performance.now()-ze);const e=Math.floor((performance.now()-this.prev)/ze);if(e>1e3)this.prev=performance.now();else for(let t=0;t<e;t++){if(this.cameraManager.update(this.playerPlane,this.dirLight),this.inputManager.keyPressed(" ")){const s=this.cameraManager.getBaseLocalPosition(),i=this.playerPlane.fire(this.scene,s);this.activeProjectiles.push(...i),i.length>0&&this.ammoCountEl&&(this.ammoCountEl.innerText=this.playerPlane.getAmmo().toString())}this._updateActiveProjectiles(),Qt(this.playerPlane.mesh,this.playerPlane.collider,this.scene,this.cameraManager.getThreeCamera(),this.terrainManager,this),this.playerPlane.updatePhysics(),this.inputManager.handlePlaneKeys(this.playerPlane),this.mode===Q.FREEFLIGHT&&this.terrainManager.handleTerrainGeneration(this.playerPlane.getPosition()),this.prev=performance.now()}}else this.staticUpdate();this.renderer.render(this.scene,this.cameraManager.getThreeCamera()),this.stats.end()});const e=window.innerWidth,t=window.innerHeight;this.assetManager=new Wt,this.inputManager=new qt,this.cameraManager=new $t(e,t),this.terrainManager=new Me(this.assetManager),this.scene=new ut,this.scene.background=new $e(Mt),this.scene.fog=new mt(this.scene.background,ce*.5,ce),this.renderer=new pt({logarithmicDepthBuffer:!0}),this.renderer.setSize(e,t),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=ft,document.body.appendChild(this.renderer.domElement),this.dirLight=new gt(16777215,3),this.dirLight.position.set(1,1,1),this.dirLight.target.position.set(0,0,0),this.dirLight.castShadow=!0,this.dirLight.shadow.bias=-.01,this.dirLight.shadow.mapSize.width=2**13,this.dirLight.shadow.mapSize.height=2**13;const s=100;this.dirLight.shadow.camera.left=-100,this.dirLight.shadow.camera.right=s,this.dirLight.shadow.camera.top=s,this.dirLight.shadow.camera.bottom=-100,this.dirLight.shadow.camera.near=0,this.dirLight.shadow.camera.far=100;const i=new yt(bt,3);this.scene.add(this.dirLight,this.dirLight.target,i,this.terrainManager.getTerrainObject3D(),this.terrainManager.getWaterMesh()),window.addEventListener("resize",this.onWindowResize),this.stand=new j(new wt(1,1,2,32),this.assetManager.standMaterial)}async initializeApp(){this.stats=new ee,document.body.appendChild(this.stats.dom);try{if(await this.assetManager.loadAllAssets(),this.terrainManager.initializeInternalPopulations(),this.assetManager.planeMesh&&this.assetManager.planeMaterial){const e=this.assetManager.planeMesh.clone();this.playerPlane=new ts(e,this.assetManager),this.scene.add(this.playerPlane.mesh),this.ammoCountEl&&(this.ammoCountEl.innerText=this.playerPlane.getAmmo().toString())}else throw new Error("CRITICAL: Player plane assets not loaded.");this.inputManager.setupGlobalInputListeners(),this.staticScene(),this.animate(),this.freeButtonEl&&(this.freeButtonEl.onclick=()=>this.enter(Q.FREEFLIGHT))}catch(e){console.error("Failed to initialize the application:",e),this.loadingEl&&(this.loadingEl.innerText="Error loading assets. Please refresh.")}}initGame(){this.menuEl&&(this.menuEl.style.display="none"),this.blackoutEl&&this.blackoutEl.classList.add("right"),this.loadingEl&&this.loadingEl.classList.remove("active"),this.waitingEl&&this.waitingEl.classList.remove("active"),this.playerPlane.setPosition(E(0,5,0)),this.playerPlane.setRotation(new W(0,0,0)),this.playerPlane.vel.local.z=-.1,this.playerPlane.mesh.add(this.cameraManager.getThreeCamera()),Ye.prepareBreakableObject(this.playerPlane.collider,1,E(0,0,0),E(0,0,0),!0),this.flying=!0,this.ammoEl&&this.ammoEl.classList.add("active")}staticScene(){this.menuEl&&(this.menuEl.style.display="flex"),this.blackoutEl&&this.blackoutEl.classList.add("left");const e=E(145,-2,0),t=this.cameraManager.getThreeCamera();this.cameraManager.setPosition(E(-1,.5,2).add(e)),this.cameraManager.setRotation(new W(0,-.1,0)),this.playerPlane.setRotation(new W(...U(E(t.rotation.x,t.rotation.y,t.rotation.z),E(-.1,Math.PI*.75,.1)))),this.playerPlane.mesh.remove(t),this.playerPlane.setPosition(E(0,0,0).add(e)),this.stand.position.set(...U(this.playerPlane.getPosition(),E(0,-1.45,0))),this.stand.castShadow=!0,this.stand.receiveShadow=!0,this.scene.add(this.stand);const s=this.playerPlane.getPosition();this.dirLight.target.position.set(s.x,10,s.z),this.dirLight.position.set(...U(this.dirLight.target.position,E(1,1,1))),this.terrainManager.handleTerrainGeneration(s),this.cameraManager.updateSavePosition()}staticUpdate(){const e=this.inputManager.getInputState(),t={x:e.mouse.x-window.innerWidth/2,y:e.mouse.y-window.innerHeight/2};this.cameraManager.updateStatic(t),this.headingEl&&(this.headingEl.style.transform=`translate(${t.x/100}px, ${t.y/100}px)`),this.selectEl&&(this.selectEl.style.transform=`translate(${t.x/200}px, ${t.y/200}px)`)}enter(e){this.blackoutEl&&(this.blackoutEl.classList.remove("left"),this.blackoutEl.classList.remove("right")),setTimeout(()=>{this.scene.remove(this.stand),this.mode=e,this.mode===Q.FREEFLIGHT&&this.initGame()},1e3)}_updateActiveProjectiles(){const e=[],t=this.playerPlane.mesh,s=this.playerPlane.collider,i=this.playerPlane.getPosition();for(const n of this.activeProjectiles){n.updateMovement();let o=!1;n.owner!==t&&!this.crashed&&n.checkCollisionWith(s)&&(Ze(t,s,this.scene,this.cameraManager.getThreeCamera(),!0,this),o=!0),!o&&n.isOutOfBounds(i)&&(o=!0),o?n.removeFromScene(this.scene):e.push(n)}this.activeProjectiles=e}setCrashed(e){this.crashed=e}getPlayerBySid(e){return this.players.find(t=>t.sid===e)}addPlayer(e){this.players.push(e)}removePlayer(e){this.players=this.players.filter(t=>t.sid!==e)}addShard(e){this.shards.push(e)}clearShards(){this.shards=[]}}const is=new ss;is.initializeApp();
