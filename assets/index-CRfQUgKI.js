var Gs=Object.defineProperty;var qs=(r,t,e)=>t in r?Gs(r,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):r[t]=e;var E=(r,t,e)=>qs(r,typeof t!="symbol"?t+"":t,e);import{L as Ws,F as Xs,C as zs,S as Ys,G as Zs,B as Ne,a as lt,b as xe,M as Qe,P as Kt,c as Ks,d as ts,e as Pe,f as W,V as L,T as Js,N as es,g as Ae,D as wt,h as $t,i as Rs,Q as Qs,j as ot,I as tn,E as Lt,k as en,l as G,A as sn,m as nn,n as ss,o as on,p as Is,q as Et,r as et,s as ht,t as xt,u as rn,v as an,R as cn,w as ns,x as ln,O as un,y as is,z as fn,H as hn,W as pn,J as dn,K as mn,U as yn,X as gn}from"./three-CTmF9W_p.js";(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const n of document.querySelectorAll('link[rel="modulepreload"]'))s(n);new MutationObserver(n=>{for(const o of n)if(o.type==="childList")for(const i of o.addedNodes)i.tagName==="LINK"&&i.rel==="modulepreload"&&s(i)}).observe(document,{childList:!0,subtree:!0});function e(n){const o={};return n.integrity&&(o.integrity=n.integrity),n.referrerPolicy&&(o.referrerPolicy=n.referrerPolicy),n.crossOrigin==="use-credentials"?o.credentials="include":n.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(n){if(n.ep)return;n.ep=!0;const o=e(n);fetch(n.href,o)}})();var qt=function(){var r=0,t=document.createElement("div");t.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",t.addEventListener("click",function(u){u.preventDefault(),s(++r%t.children.length)},!1);function e(u){return t.appendChild(u.dom),u}function s(u){for(var f=0;f<t.children.length;f++)t.children[f].style.display=f===u?"block":"none";r=u}var n=(performance||Date).now(),o=n,i=0,a=e(new qt.Panel("FPS","#0ff","#002")),c=e(new qt.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var h=e(new qt.Panel("MB","#f08","#201"));return s(0),{REVISION:16,dom:t,addPanel:e,showPanel:s,begin:function(){n=(performance||Date).now()},end:function(){i++;var u=(performance||Date).now();if(c.update(u-n,200),u>=o+1e3&&(a.update(i*1e3/(u-o),100),o=u,i=0,h)){var f=performance.memory;h.update(f.usedJSHeapSize/1048576,f.jsHeapSizeLimit/1048576)}return u},update:function(){n=this.end()},domElement:t,setMode:s}};qt.Panel=function(r,t,e){var s=1/0,n=0,o=Math.round,i=o(window.devicePixelRatio||1),a=80*i,c=48*i,h=3*i,u=2*i,f=3*i,l=15*i,p=74*i,g=30*i,w=document.createElement("canvas");w.width=a,w.height=c,w.style.cssText="width:80px;height:48px";var d=w.getContext("2d");return d.font="bold "+9*i+"px Helvetica,Arial,sans-serif",d.textBaseline="top",d.fillStyle=e,d.fillRect(0,0,a,c),d.fillStyle=t,d.fillText(r,h,u),d.fillRect(f,l,p,g),d.fillStyle=e,d.globalAlpha=.9,d.fillRect(f,l,p,g),{dom:w,update:function(m,y){s=Math.min(s,m),n=Math.max(n,m),d.fillStyle=e,d.globalAlpha=1,d.fillRect(0,0,a,l),d.fillStyle=t,d.fillText(o(m)+" "+r+" ("+o(s)+"-"+o(n)+")",h,u),d.drawImage(w,f+i,l,p-i,g,f,l,p-i,g),d.fillRect(f+p-i,l,i,g),d.fillStyle=e,d.globalAlpha=.9,d.fillRect(f+p-i,l,i,o((1-m/y)*g))}}};const wn=/^[og]\s*(.+)?/,xn=/^mtllib /,Pn=/^usemtl /,An=/^usemap /,os=/\s+/,rs=new L,be=new L,as=new L,cs=new L,q=new L,Jt=new zs;function bn(){const r={objects:[],object:{},vertices:[],normals:[],colors:[],uvs:[],materials:{},materialLibraries:[],startObject:function(t,e){if(this.object&&this.object.fromDeclaration===!1){this.object.name=t,this.object.fromDeclaration=e!==!1;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object={name:t||"",fromDeclaration:e!==!1,geometry:{vertices:[],normals:[],colors:[],uvs:[],hasUVIndices:!1},materials:[],smooth:!0,startMaterial:function(n,o){const i=this._finalize(!1);i&&(i.inherited||i.groupCount<=0)&&this.materials.splice(i.index,1);const a={index:this.materials.length,name:n||"",mtllib:Array.isArray(o)&&o.length>0?o[o.length-1]:"",smooth:i!==void 0?i.smooth:this.smooth,groupStart:i!==void 0?i.groupEnd:0,groupEnd:-1,groupCount:-1,inherited:!1,clone:function(c){const h={index:typeof c=="number"?c:this.index,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0,groupEnd:-1,groupCount:-1,inherited:!1};return h.clone=this.clone.bind(h),h}};return this.materials.push(a),a},currentMaterial:function(){if(this.materials.length>0)return this.materials[this.materials.length-1]},_finalize:function(n){const o=this.currentMaterial();if(o&&o.groupEnd===-1&&(o.groupEnd=this.geometry.vertices.length/3,o.groupCount=o.groupEnd-o.groupStart,o.inherited=!1),n&&this.materials.length>1)for(let i=this.materials.length-1;i>=0;i--)this.materials[i].groupCount<=0&&this.materials.splice(i,1);return n&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),o}},s&&s.name&&typeof s.clone=="function"){const n=s.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)},finalize:function(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)},parseVertexIndex:function(t,e){const s=parseInt(t,10);return(s>=0?s-1:s+e/3)*3},parseNormalIndex:function(t,e){const s=parseInt(t,10);return(s>=0?s-1:s+e/3)*3},parseUVIndex:function(t,e){const s=parseInt(t,10);return(s>=0?s-1:s+e/2)*2},addVertex:function(t,e,s){const n=this.vertices,o=this.object.geometry.vertices;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2]),o.push(n[s+0],n[s+1],n[s+2])},addVertexPoint:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addVertexLine:function(t){const e=this.vertices;this.object.geometry.vertices.push(e[t+0],e[t+1],e[t+2])},addNormal:function(t,e,s){const n=this.normals,o=this.object.geometry.normals;o.push(n[t+0],n[t+1],n[t+2]),o.push(n[e+0],n[e+1],n[e+2]),o.push(n[s+0],n[s+1],n[s+2])},addFaceNormal:function(t,e,s){const n=this.vertices,o=this.object.geometry.normals;rs.fromArray(n,t),be.fromArray(n,e),as.fromArray(n,s),q.subVectors(as,be),cs.subVectors(rs,be),q.cross(cs),q.normalize(),o.push(q.x,q.y,q.z),o.push(q.x,q.y,q.z),o.push(q.x,q.y,q.z)},addColor:function(t,e,s){const n=this.colors,o=this.object.geometry.colors;n[t]!==void 0&&o.push(n[t+0],n[t+1],n[t+2]),n[e]!==void 0&&o.push(n[e+0],n[e+1],n[e+2]),n[s]!==void 0&&o.push(n[s+0],n[s+1],n[s+2])},addUV:function(t,e,s){const n=this.uvs,o=this.object.geometry.uvs;o.push(n[t+0],n[t+1]),o.push(n[e+0],n[e+1]),o.push(n[s+0],n[s+1])},addDefaultUV:function(){const t=this.object.geometry.uvs;t.push(0,0),t.push(0,0),t.push(0,0)},addUVLine:function(t){const e=this.uvs;this.object.geometry.uvs.push(e[t+0],e[t+1])},addFace:function(t,e,s,n,o,i,a,c,h){const u=this.vertices.length;let f=this.parseVertexIndex(t,u),l=this.parseVertexIndex(e,u),p=this.parseVertexIndex(s,u);if(this.addVertex(f,l,p),this.addColor(f,l,p),a!==void 0&&a!==""){const g=this.normals.length;f=this.parseNormalIndex(a,g),l=this.parseNormalIndex(c,g),p=this.parseNormalIndex(h,g),this.addNormal(f,l,p)}else this.addFaceNormal(f,l,p);if(n!==void 0&&n!==""){const g=this.uvs.length;f=this.parseUVIndex(n,g),l=this.parseUVIndex(o,g),p=this.parseUVIndex(i,g),this.addUV(f,l,p),this.object.geometry.hasUVIndices=!0}else this.addDefaultUV()},addPointGeometry:function(t){this.object.geometry.type="Points";const e=this.vertices.length;for(let s=0,n=t.length;s<n;s++){const o=this.parseVertexIndex(t[s],e);this.addVertexPoint(o),this.addColor(o)}},addLineGeometry:function(t,e){this.object.geometry.type="Line";const s=this.vertices.length,n=this.uvs.length;for(let o=0,i=t.length;o<i;o++)this.addVertexLine(this.parseVertexIndex(t[o],s));for(let o=0,i=e.length;o<i;o++)this.addUVLine(this.parseUVIndex(e[o],n))}};return r.startObject("",!1),r}class Mn extends Ws{constructor(t){super(t),this.materials=null}load(t,e,s,n){const o=this,i=new Xs(this.manager);i.setPath(this.path),i.setRequestHeader(this.requestHeader),i.setWithCredentials(this.withCredentials),i.load(t,function(a){try{e(o.parse(a))}catch(c){n?n(c):console.error(c),o.manager.itemError(t)}},s,n)}setMaterials(t){return this.materials=t,this}parse(t){const e=new bn;t.indexOf(`\r
`)!==-1&&(t=t.replace(/\r\n/g,`
`)),t.indexOf(`\\
`)!==-1&&(t=t.replace(/\\\n/g,""));const s=t.split(`
`);let n=[];for(let a=0,c=s.length;a<c;a++){const h=s[a].trimStart();if(h.length===0)continue;const u=h.charAt(0);if(u!=="#")if(u==="v"){const f=h.split(os);switch(f[0]){case"v":e.vertices.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3])),f.length>=7?(Jt.setRGB(parseFloat(f[4]),parseFloat(f[5]),parseFloat(f[6]),Ys),e.colors.push(Jt.r,Jt.g,Jt.b)):e.colors.push(void 0,void 0,void 0);break;case"vn":e.normals.push(parseFloat(f[1]),parseFloat(f[2]),parseFloat(f[3]));break;case"vt":e.uvs.push(parseFloat(f[1]),parseFloat(f[2]));break}}else if(u==="f"){const l=h.slice(1).trim().split(os),p=[];for(let w=0,d=l.length;w<d;w++){const m=l[w];if(m.length>0){const y=m.split("/");p.push(y)}}const g=p[0];for(let w=1,d=p.length-1;w<d;w++){const m=p[w],y=p[w+1];e.addFace(g[0],m[0],y[0],g[1],m[1],y[1],g[2],m[2],y[2])}}else if(u==="l"){const f=h.substring(1).trim().split(" ");let l=[];const p=[];if(h.indexOf("/")===-1)l=f;else for(let g=0,w=f.length;g<w;g++){const d=f[g].split("/");d[0]!==""&&l.push(d[0]),d[1]!==""&&p.push(d[1])}e.addLineGeometry(l,p)}else if(u==="p"){const l=h.slice(1).trim().split(" ");e.addPointGeometry(l)}else if((n=wn.exec(h))!==null){const f=(" "+n[0].slice(1).trim()).slice(1);e.startObject(f)}else if(Pn.test(h))e.object.startMaterial(h.substring(7).trim(),e.materialLibraries);else if(xn.test(h))e.materialLibraries.push(h.substring(7).trim());else if(An.test(h))console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');else if(u==="s"){if(n=h.split(" "),n.length>1){const l=n[1].trim().toLowerCase();e.object.smooth=l!=="0"&&l!=="off"}else e.object.smooth=!0;const f=e.object.currentMaterial();f&&(f.smooth=e.object.smooth)}else{if(h==="\0")continue;console.warn('THREE.OBJLoader: Unexpected line: "'+h+'"')}}e.finalize();const o=new Zs;if(o.materialLibraries=[].concat(e.materialLibraries),!(e.objects.length===1&&e.objects[0].geometry.vertices.length===0)===!0)for(let a=0,c=e.objects.length;a<c;a++){const h=e.objects[a],u=h.geometry,f=h.materials,l=u.type==="Line",p=u.type==="Points";let g=!1;if(u.vertices.length===0)continue;const w=new Ne;w.setAttribute("position",new lt(u.vertices,3)),u.normals.length>0&&w.setAttribute("normal",new lt(u.normals,3)),u.colors.length>0&&(g=!0,w.setAttribute("color",new lt(u.colors,3))),u.hasUVIndices===!0&&w.setAttribute("uv",new lt(u.uvs,2));const d=[];for(let y=0,x=f.length;y<x;y++){const b=f[y],P=b.name+"_"+b.smooth+"_"+g;let A=e.materials[P];if(this.materials!==null){if(A=this.materials.create(b.name),l&&A&&!(A instanceof xe)){const T=new xe;Qe.prototype.copy.call(T,A),T.color.copy(A.color),A=T}else if(p&&A&&!(A instanceof Kt)){const T=new Kt({size:10,sizeAttenuation:!1});Qe.prototype.copy.call(T,A),T.color.copy(A.color),T.map=A.map,A=T}}A===void 0&&(l?A=new xe:p?A=new Kt({size:1,sizeAttenuation:!1}):A=new Ks,A.name=b.name,A.flatShading=!b.smooth,A.vertexColors=g,e.materials[P]=A),d.push(A)}let m;if(d.length>1){for(let y=0,x=f.length;y<x;y++){const b=f[y];w.addGroup(b.groupStart,b.groupCount,y)}l?m=new ts(w,d):p?m=new Pe(w,d):m=new W(w,d)}else l?m=new ts(w,d[0]):p?m=new Pe(w,d[0]):m=new W(w,d[0]);m.name=h.name,o.add(m)}else if(e.vertices.length>0){const a=new Kt({size:1,sizeAttenuation:!1}),c=new Ne;c.setAttribute("position",new lt(e.vertices,3)),e.colors.length>0&&e.colors[0]!==void 0&&(c.setAttribute("color",new lt(e.colors,3)),a.vertexColors=!0);const h=new Pe(c,a);o.add(h)}return o}}const ls=1e3,us=25,me=1e4,J=100,Tn=10,vn=2.5,fs=1e-4,hs=1e-4,ps=1e-4,Me=.99,Sn=1e-4,_n=8900331,Bn=7566195,Ln=6316128,En=3904470,Cn=14534787,Vn=4749082,Fn=7773009,zn=16777215,ds=12892835,ms=8297810,Rn=3947580,ys=16777184,In={lim0:{value:0,color:Cn},lim1:{value:10,color:Vn},lim2:{value:100,color:Fn},lim3:{value:175,color:zn}},gs=5,Dn=100,Nn=200;class jn{constructor(){E(this,"objLoader");E(this,"threeTone");E(this,"planeMaterial");E(this,"terrainMaterial");E(this,"waterMaterial");E(this,"volcanoMaterial");E(this,"weaponMaterial");E(this,"standMaterial");E(this,"planeMesh");E(this,"volcanoBaseGeometry",null);E(this,"groupTree",[]);E(this,"groupPalm",[]);E(this,"weaponModel");this.objLoader=new Mn,this.threeTone=new Js().load("/textures/fiveTone.jpg"),this.threeTone.minFilter=es,this.threeTone.magFilter=es,this.planeMaterial=new Ae({color:Ln,side:wt}),this.terrainMaterial=new $t({vertexColors:!0,side:wt,gradientMap:this.threeTone}),this.waterMaterial=new Ae({color:En,side:wt,transparent:!0,opacity:.8}),this.volcanoMaterial=new $t({color:Rn,side:wt,gradientMap:this.threeTone}),this.weaponMaterial=new Ae({color:ys,emissive:ys}),this.standMaterial=new $t({color:12566463,gradientMap:this.threeTone}),this.weaponModel=new W(new Rs(.1,.1,2),this.weaponMaterial)}createPropMaterial(t){return new $t({color:t,side:wt,gradientMap:this.threeTone})}load(t,e,s){return new Promise((n,o)=>{this.objLoader.load(t,i=>{i.traverse(a=>{a instanceof W&&(a.material=e,a.geometry.computeVertexNormals(!0),a.castShadow=!0)}),i.scale.set(s,s,s),n(i)},i=>{`${t}`,i.loaded/i.total*100},i=>{console.error(`Error loading model from ${t}:`,i),o(new Error(`Failed to load OBJ model from ${t}`))})})}loadGeometry(t){return new Promise((e,s)=>{let n;this.objLoader.load(t,o=>{o.traverse(i=>{i instanceof W&&(i.geometry.computeVertexNormals(!0),n=i.geometry)}),n?e({path:t,geometry:n}):(console.error(`No geometry found in loaded mesh from ${t}`),s(new Error(`No geometry found in ${t}`)))},o=>{`${t}`,o.loaded/o.total*100},o=>{console.error(`Error loading geometry from ${t}:`,o),s(new Error(`Failed to load geometry from ${t}`))})})}async gLoad(t){const e=[],s=t.map(async o=>{try{const{geometry:i}=await this.loadGeometry(o.path),a=this.createPropMaterial(o.color);return new W(i,a)}catch(i){return console.error(`Failed to load geometry for gLoad: ${o.path}`,i),null}});return(await Promise.all(s)).forEach(o=>{o&&e.push(o)}),e}async loadAllAssets(){try{const t=await this.load("/models/vehicle/airplane.obj",this.planeMaterial,.1);this.planeMesh=t;const e=await this.loadGeometry("/models/maps/volcano_base.obj");this.volcanoBaseGeometry=e.geometry;const s=[this.gLoad([{path:"/models/tree/tree_trunk.obj",color:ds},{path:"/models/tree/tree_leaves.obj",color:ms}]),this.gLoad([{path:"/models/palm_tree/trunk.obj",color:ds},{path:"/models/palm_tree/leaves.obj",color:ms}])],[n,o]=await Promise.all(s);this.groupTree=n,this.groupPalm=o}catch(t){throw console.error("Error loading assets in AssetManager:",t),t}}}function I(...r){if(r.length===1){const t=r[0];if(Array.isArray(t))return new L(...t);if(t instanceof L)return t}return r.length===3?new L(r[0],r[1],r[2]):new L}function Ct(r,t){const e=r instanceof L?r:new L(...r),s=t instanceof L?t:new L(...t),n=e.clone().add(s);return[n.x,n.y,n.z]}function je(r){return[r.x,r.y,r.z]}function Un(r){let t=r.toString(16);for(;t.length<6;)t=`0${t}`;const e=(s,n)=>parseInt(t.substring(s,n),16)/255;return[e(0,2),e(2,4),e(4,6)]}function kn(r,t,e){const s=new Qs;return s.setFromEuler(t),new ot().compose(r,s,e)}function On(r,t){const e=new tn(r.geometry,r.material,t.length);e.castShadow=!0,e.receiveShadow=!0;for(let s=0;s<t.length;s++)e.setMatrixAt(s,t[s]);return e}class $n{constructor(t,e){E(this,"camera");E(this,"baseLocalPos",I(0,10,20));E(this,"baseLocalRot",new Lt(0,0,0));E(this,"save",I(0,10,20));E(this,"factor",500);this.camera=new en(75,t/e,.1,1e4),this.camera.position.copy(this.baseLocalPos),this.camera.rotation.copy(this.baseLocalRot)}getThreeCamera(){return this.camera}handleResize(t,e){this.camera.aspect=t/e,this.camera.updateProjectionMatrix()}updateSavePosition(){this.save=this.camera.position.clone()}getBaseLocalPosition(){return this.baseLocalPos}setPosition(t){this.camera.position.copy(t)}setRotation(t){this.camera.rotation.copy(t)}update(t,e){const s=I(-t.rotVel.yaw*this.factor,t.rotVel.pitch*this.factor,-t.vel.local.z/10*this.factor);if(this.camera.position.set(...Ct(this.baseLocalPos,s)),this.camera.rotation.copy(this.baseLocalRot),e){const n=t.getPosition();e.target.position.copy(n),e.position.set(n.x+1,n.y+1,n.z+1)}}updateStatic(t){this.camera.position.set(...Ct(this.save,I(-t.x/4e3,t.y/4e3,0)))}}class Hn{constructor(){E(this,"_inputState");this._inputState={keys:{},mouse:{x:0,y:0}}}_updateKey(t,e){this._inputState.keys[t]=e}_updateMousePosition(t,e){this._inputState.mouse.x=t,this._inputState.mouse.y=e}keyPressed(t){return this._inputState.keys.hasOwnProperty(t)?this._inputState.keys[t]:!1}handlePlaneKeys(t){if(!t)return;let e=t.rotVel;this.keyPressed("ArrowUp")&&(e.pitch+=hs),this.keyPressed("ArrowDown")&&(e.pitch-=hs),this.keyPressed("ArrowLeft")&&(e.yaw+=fs),this.keyPressed("ArrowRight")&&(e.yaw-=fs),this.keyPressed("a")&&(e.roll+=ps),this.keyPressed("d")&&(e.roll-=ps),t.rotVel=e,this.keyPressed("w")?t.thrust=Sn:this.keyPressed("s")?t.thrust=-1e-4:t.thrust=0}setupGlobalInputListeners(){const t=s=>{this._updateKey(s.key,s.type==="keydown")};document.removeEventListener("keydown",t),document.removeEventListener("keyup",t),document.addEventListener("keydown",t),document.addEventListener("keyup",t);const e=s=>{this._updateMousePosition(s.clientX,s.clientY)};document.removeEventListener("mousemove",e),document.addEventListener("mousemove",e)}getInputState(){return this._inputState}}const Gn=500;class ws{constructor(t,e){E(this,"mesh");E(this,"owner");this.mesh=t,this.owner=e}updateMovement(){this.mesh.translateZ(-2)}isOutOfBounds(t){return this.mesh.position.distanceTo(t)>Gn}getBoundingBox(){return new G().setFromObject(this.mesh)}checkCollisionWith(t){if(this.owner===t)return!1;const e=new G().setFromObject(t);return this.getBoundingBox().intersectsBox(e)}removeFromScene(t){t.remove(this.mesh)}}class qn{constructor(t,e){E(this,"mesh");E(this,"collider");E(this,"assetManager");E(this,"ammo",Nn);E(this,"lastWeaponFireTime",0);E(this,"thrust",1e-4);E(this,"vel",{global:I(0,0,0),local:I(0,0,0)});E(this,"rot",{yaw:0,roll:0,pitch:0});E(this,"rotVel",{yaw:0,roll:0,pitch:0});this.mesh=t,this.assetManager=e,this.lastWeaponFireTime=0,this.collider=new W(new Rs(10,1,20),this.assetManager.planeMaterial),this.collider.visible=!1,this.mesh.add(this.collider)}getAmmo(){return this.ammo}canFire(){return(performance.now()-this.lastWeaponFireTime>Dn||this.lastWeaponFireTime===0)&&this.ammo>0}fire(t,e){if(!this.canFire())return[];this.ammo--,this.lastWeaponFireTime=performance.now();const s=a=>{const c=I(Ct(e.clone().multiplyScalar(-1),I(a,2,-10)));return this.mesh.localToWorld(c.clone())},n=[],o=this.assetManager.weaponModel.clone();o.position.set(...je(s(-10))),o.rotation.copy(this.mesh.rotation),t.add(o),n.push(new ws(o,this.mesh));const i=this.assetManager.weaponModel.clone();return i.position.set(...je(s(10))),i.rotation.copy(this.mesh.rotation),t.add(i),n.push(new ws(i,this.mesh)),n}updatePhysics(){this.mesh.position.add(this.vel.global),this.mesh.translateX(this.vel.local.x),this.mesh.translateY(this.vel.local.y),this.mesh.translateZ(this.vel.local.z);let t=this.vel.local.z-this.thrust;t>0&&(t=0),this.vel.local.z=t;const e=this.vel.local.z<0?1e-6/-this.vel.local.z:1e-5;this.vel.global.y-=e,this.rotVel.pitch*=Me,this.rotVel.roll*=Me,this.rotVel.yaw*=Me,this.rot.pitch+=this.rotVel.pitch,this.rot.roll+=this.rotVel.roll,this.rot.yaw+=this.rotVel.yaw,this.mesh.rotateX(this.rotVel.pitch),this.mesh.rotateZ(this.rotVel.roll),this.mesh.rotateY(this.rotVel.yaw)}updateCollisions(){}getPosition(){return this.mesh.position.clone()}getRotation(){return this.mesh.rotation.clone()}setPosition(t){this.mesh.position.copy(t)}setRotation(t){this.mesh.rotation.copy(t)}}class Wn{constructor(t){E(this,"listener");E(this,"audioLoader");E(this,"sounds");E(this,"positionalSounds");E(this,"ENABLED",!0);this.listener=new sn,this.ENABLED||this.listener.setMasterVolume(0),t.add(this.listener),this.audioLoader=new nn,this.sounds=new Map,this.positionalSounds=new Map}async loadAllSounds(){await Promise.all([this.loadSound("plane-flying","sounds/plane-flying.mp3"),this.loadSound("plane-shooting","sounds/plane-shooting.mp3"),this.loadSound("plane-exploding","sounds/plane-exploding.mp3")])}async loadSound(t,e){return new Promise((s,n)=>{this.audioLoader.load(e,o=>{this.sounds.set(t,o),s()},void 0,o=>{console.error(`Error loading sound ${t}:`,o),n(o)})})}createPositionalSound(t){const e=this.sounds.get(t);if(e){const s=new ss(this.listener);return s.setBuffer(e),this.positionalSounds.set(t,s),s}console.warn(`Audio buffer not found for sound: ${t}`)}updatePlaneSound(t,e){const s="plane-flying";let n=this.positionalSounds.get(s);n||(n=this.createPositionalSound(s),n&&(e.add(n),n.setVolume(2),n.setLoop(!0),n.play()));const a=1+t*1;n==null||n.setPlaybackRate(a)}playShootingSound(t){const e="plane-shooting",s=this.sounds.get(e);if(s){const n=new ss(this.listener);n.setBuffer(s),n.setVolume(3),t.add(n),n.play()}else console.warn(`Audio buffer not found for sound: ${e}`)}playExplosionSound(){const t="plane-exploding",e=this.sounds.get(t);if(e){const s=new on(this.listener);s.setBuffer(e),s.play()}else console.warn(`Audio buffer not found for sound: ${t}`)}}const Ds=0,Xn=1,Yn=2,xs=2,Te=1.25,Ps=1,Wt=6*4+4+4,ge=65535,Zn=Math.pow(2,-24),ve=Symbol("SKIP_GENERATION");function Kn(r){return r.index?r.index.count:r.attributes.position.count}function Vt(r){return Kn(r)/3}function Jn(r,t=ArrayBuffer){return r>65535?new Uint32Array(new t(4*r)):new Uint16Array(new t(2*r))}function Qn(r,t){if(!r.index){const e=r.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=Jn(e,s);r.setIndex(new Is(n,1));for(let o=0;o<e;o++)n[o]=o}}function Ns(r,t){const e=Vt(r),s=t||r.drawRange,n=s.start/3,o=(s.start+s.count)/3,i=Math.max(0,n),a=Math.min(e,o)-i;return[{offset:Math.floor(i),count:Math.floor(a)}]}function js(r,t){if(!r.groups||!r.groups.length)return Ns(r,t);const e=[],s=new Set,n=t||r.drawRange,o=n.start/3,i=(n.start+n.count)/3;for(const c of r.groups){const h=c.start/3,u=(c.start+c.count)/3;s.add(Math.max(o,h)),s.add(Math.min(i,u))}const a=Array.from(s.values()).sort((c,h)=>c-h);for(let c=0;c<a.length-1;c++){const h=a[c],u=a[c+1];e.push({offset:Math.floor(h),count:Math.floor(u-h)})}return e}function ti(r,t){const e=Vt(r),s=js(r,t).sort((i,a)=>i.offset-a.offset),n=s[s.length-1];n.count=Math.min(e-n.offset,n.count);let o=0;return s.forEach(({count:i})=>o+=i),e!==o}function Se(r,t,e,s,n){let o=1/0,i=1/0,a=1/0,c=-1/0,h=-1/0,u=-1/0,f=1/0,l=1/0,p=1/0,g=-1/0,w=-1/0,d=-1/0;for(let m=t*6,y=(t+e)*6;m<y;m+=6){const x=r[m+0],b=r[m+1],P=x-b,A=x+b;P<o&&(o=P),A>c&&(c=A),x<f&&(f=x),x>g&&(g=x);const T=r[m+2],S=r[m+3],v=T-S,B=T+S;v<i&&(i=v),B>h&&(h=B),T<l&&(l=T),T>w&&(w=T);const C=r[m+4],M=r[m+5],_=C-M,V=C+M;_<a&&(a=_),V>u&&(u=V),C<p&&(p=C),C>d&&(d=C)}s[0]=o,s[1]=i,s[2]=a,s[3]=c,s[4]=h,s[5]=u,n[0]=f,n[1]=l,n[2]=p,n[3]=g,n[4]=w,n[5]=d}function ei(r,t=null,e=null,s=null){const n=r.attributes.position,o=r.index?r.index.array:null,i=Vt(r),a=n.normalized;let c;t===null?(c=new Float32Array(i*6),e=0,s=i):(c=t,e=e||0,s=s||i);const h=n.array,u=n.offset||0;let f=3;n.isInterleavedBufferAttribute&&(f=n.data.stride);const l=["getX","getY","getZ"];for(let p=e;p<e+s;p++){const g=p*3,w=p*6;let d=g+0,m=g+1,y=g+2;o&&(d=o[d],m=o[m],y=o[y]),a||(d=d*f+u,m=m*f+u,y=y*f+u);for(let x=0;x<3;x++){let b,P,A;a?(b=n[l[x]](d),P=n[l[x]](m),A=n[l[x]](y)):(b=h[d+x],P=h[m+x],A=h[y+x]);let T=b;P<T&&(T=P),A<T&&(T=A);let S=b;P>S&&(S=P),A>S&&(S=A);const v=(S-T)/2,B=x*2;c[w+B+0]=T+v,c[w+B+1]=v+(Math.abs(T)+v)*Zn}}return c}function N(r,t,e){return e.min.x=t[r],e.min.y=t[r+1],e.min.z=t[r+2],e.max.x=t[r+3],e.max.y=t[r+4],e.max.z=t[r+5],e}function As(r){let t=-1,e=-1/0;for(let s=0;s<3;s++){const n=r[s+3]-r[s];n>e&&(e=n,t=s)}return t}function bs(r,t){t.set(r)}function Ms(r,t,e){let s,n;for(let o=0;o<3;o++){const i=o+3;s=r[o],n=t[o],e[o]=s<n?s:n,s=r[i],n=t[i],e[i]=s>n?s:n}}function Qt(r,t,e){for(let s=0;s<3;s++){const n=t[r+2*s],o=t[r+2*s+1],i=n-o,a=n+o;i<e[s]&&(e[s]=i),a>e[s+3]&&(e[s+3]=a)}}function It(r){const t=r[3]-r[0],e=r[4]-r[1],s=r[5]-r[2];return 2*(t*e+e*s+s*t)}const it=32,si=(r,t)=>r.candidate-t.candidate,at=new Array(it).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),te=new Float32Array(6);function ni(r,t,e,s,n,o){let i=-1,a=0;if(o===Ds)i=As(t),i!==-1&&(a=(t[i]+t[i+3])/2);else if(o===Xn)i=As(r),i!==-1&&(a=ii(e,s,n,i));else if(o===Yn){const c=It(r);let h=Te*n;const u=s*6,f=(s+n)*6;for(let l=0;l<3;l++){const p=t[l],d=(t[l+3]-p)/it;if(n<it/4){const m=[...at];m.length=n;let y=0;for(let b=u;b<f;b+=6,y++){const P=m[y];P.candidate=e[b+2*l],P.count=0;const{bounds:A,leftCacheBounds:T,rightCacheBounds:S}=P;for(let v=0;v<3;v++)S[v]=1/0,S[v+3]=-1/0,T[v]=1/0,T[v+3]=-1/0,A[v]=1/0,A[v+3]=-1/0;Qt(b,e,A)}m.sort(si);let x=n;for(let b=0;b<x;b++){const P=m[b];for(;b+1<x&&m[b+1].candidate===P.candidate;)m.splice(b+1,1),x--}for(let b=u;b<f;b+=6){const P=e[b+2*l];for(let A=0;A<x;A++){const T=m[A];P>=T.candidate?Qt(b,e,T.rightCacheBounds):(Qt(b,e,T.leftCacheBounds),T.count++)}}for(let b=0;b<x;b++){const P=m[b],A=P.count,T=n-P.count,S=P.leftCacheBounds,v=P.rightCacheBounds;let B=0;A!==0&&(B=It(S)/c);let C=0;T!==0&&(C=It(v)/c);const M=Ps+Te*(B*A+C*T);M<h&&(i=l,h=M,a=P.candidate)}}else{for(let x=0;x<it;x++){const b=at[x];b.count=0,b.candidate=p+d+x*d;const P=b.bounds;for(let A=0;A<3;A++)P[A]=1/0,P[A+3]=-1/0}for(let x=u;x<f;x+=6){let A=~~((e[x+2*l]-p)/d);A>=it&&(A=it-1);const T=at[A];T.count++,Qt(x,e,T.bounds)}const m=at[it-1];bs(m.bounds,m.rightCacheBounds);for(let x=it-2;x>=0;x--){const b=at[x],P=at[x+1];Ms(b.bounds,P.rightCacheBounds,b.rightCacheBounds)}let y=0;for(let x=0;x<it-1;x++){const b=at[x],P=b.count,A=b.bounds,S=at[x+1].rightCacheBounds;P!==0&&(y===0?bs(A,te):Ms(A,te,te)),y+=P;let v=0,B=0;y!==0&&(v=It(te)/c);const C=n-y;C!==0&&(B=It(S)/c);const M=Ps+Te*(v*y+B*C);M<h&&(i=l,h=M,a=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${o} used.`);return{axis:i,pos:a}}function ii(r,t,e,s){let n=0;for(let o=t,i=t+e;o<i;o++)n+=r[o*6+s*2];return n/e}class _e{constructor(){this.boundingData=new Float32Array(6)}}function oi(r,t,e,s,n,o){let i=s,a=s+n-1;const c=o.pos,h=o.axis*2;for(;;){for(;i<=a&&e[i*6+h]<c;)i++;for(;i<=a&&e[a*6+h]>=c;)a--;if(i<a){for(let u=0;u<3;u++){let f=t[i*3+u];t[i*3+u]=t[a*3+u],t[a*3+u]=f}for(let u=0;u<6;u++){let f=e[i*6+u];e[i*6+u]=e[a*6+u],e[a*6+u]=f}i++,a--}else return i}}function ri(r,t,e,s,n,o){let i=s,a=s+n-1;const c=o.pos,h=o.axis*2;for(;;){for(;i<=a&&e[i*6+h]<c;)i++;for(;i<=a&&e[a*6+h]>=c;)a--;if(i<a){let u=r[i];r[i]=r[a],r[a]=u;for(let f=0;f<6;f++){let l=e[i*6+f];e[i*6+f]=e[a*6+f],e[a*6+f]=l}i++,a--}else return i}}function $(r,t){return t[r+15]===65535}function H(r,t){return t[r+6]}function X(r,t){return t[r+14]}function Y(r){return r+8}function Z(r,t){return t[r+6]}function Us(r,t){return t[r+7]}let ks,Ht,pe,Os;const ai=Math.pow(2,32);function Ue(r){return"count"in r?1:1+Ue(r.left)+Ue(r.right)}function ci(r,t,e){return ks=new Float32Array(e),Ht=new Uint32Array(e),pe=new Uint16Array(e),Os=new Uint8Array(e),ke(r,t)}function ke(r,t){const e=r/4,s=r/2,n="count"in t,o=t.boundingData;for(let i=0;i<6;i++)ks[e+i]=o[i];if(n)if(t.buffer){const i=t.buffer;Os.set(new Uint8Array(i),r);for(let a=r,c=r+i.byteLength;a<c;a+=Wt){const h=a/2;$(h,pe)||(Ht[a/4+6]+=e)}return r+i.byteLength}else{const i=t.offset,a=t.count;return Ht[e+6]=i,pe[s+14]=a,pe[s+15]=ge,r+Wt}else{const i=t.left,a=t.right,c=t.splitAxis;let h;if(h=ke(r+Wt,i),h/4>ai)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Ht[e+6]=h/4,h=ke(h,a),Ht[e+7]=c,h}}function li(r,t){const e=(r.index?r.index.count:r.attributes.position.count)/3,s=e>2**16,n=s?4:2,o=t?new SharedArrayBuffer(e*n):new ArrayBuffer(e*n),i=s?new Uint32Array(o):new Uint16Array(o);for(let a=0,c=i.length;a<c;a++)i[a]=a;return i}function ui(r,t,e,s,n){const{maxDepth:o,verbose:i,maxLeafTris:a,strategy:c,onProgress:h,indirect:u}=n,f=r._indirectBuffer,l=r.geometry,p=l.index?l.index.array:null,g=u?ri:oi,w=Vt(l),d=new Float32Array(6);let m=!1;const y=new _e;return Se(t,e,s,y.boundingData,d),b(y,e,s,d),y;function x(P){h&&h(P/w)}function b(P,A,T,S=null,v=0){if(!m&&v>=o&&(m=!0,i&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(l))),T<=a||v>=o)return x(A+T),P.offset=A,P.count=T,P;const B=ni(P.boundingData,S,t,A,T,c);if(B.axis===-1)return x(A+T),P.offset=A,P.count=T,P;const C=g(f,p,t,A,T,B);if(C===A||C===A+T)x(A+T),P.offset=A,P.count=T;else{P.splitAxis=B.axis;const M=new _e,_=A,V=C-A;P.left=M,Se(t,_,V,M.boundingData,d),b(M,_,V,d,v+1);const F=new _e,z=C,D=T-V;P.right=F,Se(t,z,D,F.boundingData,d),b(F,z,D,d,v+1)}return P}}function fi(r,t){const e=r.geometry;t.indirect&&(r._indirectBuffer=li(e,t.useSharedArrayBuffer),ti(e,t.range)&&!t.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),r._indirectBuffer||Qn(e,t);const s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,n=ei(e),o=t.indirect?Ns(e,t.range):js(e,t.range);r._roots=o.map(i=>{const a=ui(r,n,i.offset,i.count,t),c=Ue(a),h=new s(Wt*c);return ci(0,a,h),h})}class rt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,n=-1/0;for(let o=0,i=t.length;o<i;o++){const c=t[o][e];s=c<s?c:s,n=c>n?c:n}this.min=s,this.max=n}setFromPoints(t,e){let s=1/0,n=-1/0;for(let o=0,i=e.length;o<i;o++){const a=e[o],c=t.dot(a);s=c<s?c:s,n=c>n?c:n}this.min=s,this.max=n}isSeparated(t){return this.min>t.max||t.min>this.max}}rt.prototype.setFromBox=function(){const r=new L;return function(e,s){const n=s.min,o=s.max;let i=1/0,a=-1/0;for(let c=0;c<=1;c++)for(let h=0;h<=1;h++)for(let u=0;u<=1;u++){r.x=n.x*c+o.x*(1-c),r.y=n.y*h+o.y*(1-h),r.z=n.z*u+o.z*(1-u);const f=e.dot(r);i=Math.min(f,i),a=Math.max(f,a)}this.min=i,this.max=a}}();const hi=function(){const r=new L,t=new L,e=new L;return function(n,o,i){const a=n.start,c=r,h=o.start,u=t;e.subVectors(a,h),r.subVectors(n.end,n.start),t.subVectors(o.end,o.start);const f=e.dot(u),l=u.dot(c),p=u.dot(u),g=e.dot(c),d=c.dot(c)*p-l*l;let m,y;d!==0?m=(f*l-g*p)/d:m=0,y=(f+m*l)/p,i.x=m,i.y=y}}(),Ze=function(){const r=new ht,t=new L,e=new L;return function(n,o,i,a){hi(n,o,r);let c=r.x,h=r.y;if(c>=0&&c<=1&&h>=0&&h<=1){n.at(c,i),o.at(h,a);return}else if(c>=0&&c<=1){h<0?o.at(0,a):o.at(1,a),n.closestPointToPoint(a,!0,i);return}else if(h>=0&&h<=1){c<0?n.at(0,i):n.at(1,i),o.closestPointToPoint(i,!0,a);return}else{let u;c<0?u=n.start:u=n.end;let f;h<0?f=o.start:f=o.end;const l=t,p=e;if(n.closestPointToPoint(f,!0,t),o.closestPointToPoint(u,!0,e),l.distanceToSquared(f)<=p.distanceToSquared(u)){i.copy(l),a.copy(f);return}else{i.copy(u),a.copy(p);return}}}}(),pi=function(){const r=new L,t=new L,e=new Et,s=new et;return function(o,i){const{radius:a,center:c}=o,{a:h,b:u,c:f}=i;if(s.start=h,s.end=u,s.closestPointToPoint(c,!0,r).distanceTo(c)<=a||(s.start=h,s.end=f,s.closestPointToPoint(c,!0,r).distanceTo(c)<=a)||(s.start=u,s.end=f,s.closestPointToPoint(c,!0,r).distanceTo(c)<=a))return!0;const w=i.getPlane(e);if(Math.abs(w.distanceToPoint(c))<=a){const m=w.projectPoint(c,t);if(i.containsPoint(m))return!0}return!1}}(),di=1e-15;function Be(r){return Math.abs(r)<di}class st extends xt{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new L),this.satBounds=new Array(4).fill().map(()=>new rt),this.points=[this.a,this.b,this.c],this.sphere=new rn,this.plane=new Et,this.needsUpdate=!0}intersectsSphere(t){return pi(t,this)}update(){const t=this.a,e=this.b,s=this.c,n=this.points,o=this.satAxes,i=this.satBounds,a=o[0],c=i[0];this.getNormal(a),c.setFromPoints(a,n);const h=o[1],u=i[1];h.subVectors(t,e),u.setFromPoints(h,n);const f=o[2],l=i[2];f.subVectors(e,s),l.setFromPoints(f,n);const p=o[3],g=i[3];p.subVectors(s,t),g.setFromPoints(p,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(a,t),this.needsUpdate=!1}}st.prototype.closestPointToSegment=function(){const r=new L,t=new L,e=new et;return function(n,o=null,i=null){const{start:a,end:c}=n,h=this.points;let u,f=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;e.start.copy(h[l]),e.end.copy(h[p]),Ze(e,n,r,t),u=r.distanceToSquared(t),u<f&&(f=u,o&&o.copy(r),i&&i.copy(t))}return this.closestPointToPoint(a,r),u=a.distanceToSquared(r),u<f&&(f=u,o&&o.copy(r),i&&i.copy(a)),this.closestPointToPoint(c,r),u=c.distanceToSquared(r),u<f&&(f=u,o&&o.copy(r),i&&i.copy(c)),Math.sqrt(f)}}();st.prototype.intersectsTriangle=function(){const r=new st,t=new Array(3),e=new Array(3),s=new rt,n=new rt,o=new L,i=new L,a=new L,c=new L,h=new L,u=new et,f=new et,l=new et,p=new L;function g(w,d,m){const y=w.points;let x=0,b=-1;for(let P=0;P<3;P++){const{start:A,end:T}=u;A.copy(y[P]),T.copy(y[(P+1)%3]),u.delta(i);const S=Be(d.distanceToPoint(A));if(Be(d.normal.dot(i))&&S){m.copy(u),x=2;break}const v=d.intersectLine(u,p);if(!v&&S&&p.copy(A),(v||S)&&!Be(p.distanceTo(T))){if(x<=1)(x===1?m.start:m.end).copy(p),S&&(b=x);else if(x>=2){(b===1?m.start:m.end).copy(p),x=2;break}if(x++,x===2&&b===-1)break}}return x}return function(d,m=null,y=!1){this.needsUpdate&&this.update(),d.isExtendedTriangle?d.needsUpdate&&d.update():(r.copy(d),r.update(),d=r);const x=this.plane,b=d.plane;if(Math.abs(x.normal.dot(b.normal))>1-1e-10){const P=this.satBounds,A=this.satAxes;e[0]=d.a,e[1]=d.b,e[2]=d.c;for(let v=0;v<4;v++){const B=P[v],C=A[v];if(s.setFromPoints(C,e),B.isSeparated(s))return!1}const T=d.satBounds,S=d.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let v=0;v<4;v++){const B=T[v],C=S[v];if(s.setFromPoints(C,t),B.isSeparated(s))return!1}for(let v=0;v<4;v++){const B=A[v];for(let C=0;C<4;C++){const M=S[C];if(o.crossVectors(B,M),s.setFromPoints(o,t),n.setFromPoints(o,e),s.isSeparated(n))return!1}}return m&&(y||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),m.start.set(0,0,0),m.end.set(0,0,0)),!0}else{const P=g(this,b,f);if(P===1&&d.containsPoint(f.end))return m&&(m.start.copy(f.end),m.end.copy(f.end)),!0;if(P!==2)return!1;const A=g(d,x,l);if(A===1&&this.containsPoint(l.end))return m&&(m.start.copy(l.end),m.end.copy(l.end)),!0;if(A!==2)return!1;if(f.delta(a),l.delta(c),a.dot(c)<0){let _=l.start;l.start=l.end,l.end=_}const T=f.start.dot(a),S=f.end.dot(a),v=l.start.dot(a),B=l.end.dot(a),C=S<v,M=T<B;return T!==B&&v!==S&&C===M?!1:(m&&(h.subVectors(f.start,l.start),h.dot(a)>0?m.start.copy(f.start):m.start.copy(l.start),h.subVectors(f.end,l.end),h.dot(a)<0?m.end.copy(f.end):m.end.copy(l.end)),!0)}}}();st.prototype.distanceToPoint=function(){const r=new L;return function(e){return this.closestPointToPoint(e,r),e.distanceTo(r)}}();st.prototype.distanceToTriangle=function(){const r=new L,t=new L,e=["a","b","c"],s=new et,n=new et;return function(i,a=null,c=null){const h=a||c?s:null;if(this.intersectsTriangle(i,h))return(a||c)&&(a&&h.getCenter(a),c&&h.getCenter(c)),0;let u=1/0;for(let f=0;f<3;f++){let l;const p=e[f],g=i[p];this.closestPointToPoint(g,r),l=g.distanceToSquared(r),l<u&&(u=l,a&&a.copy(r),c&&c.copy(g));const w=this[p];i.closestPointToPoint(w,r),l=w.distanceToSquared(r),l<u&&(u=l,a&&a.copy(w),c&&c.copy(r))}for(let f=0;f<3;f++){const l=e[f],p=e[(f+1)%3];s.set(this[l],this[p]);for(let g=0;g<3;g++){const w=e[g],d=e[(g+1)%3];n.set(i[w],i[d]),Ze(s,n,r,t);const m=r.distanceToSquared(t);m<u&&(u=m,a&&a.copy(r),c&&c.copy(t))}}return Math.sqrt(u)}}();class O{constructor(t,e,s){this.isOrientedBox=!0,this.min=new L,this.max=new L,this.matrix=new ot,this.invMatrix=new ot,this.points=new Array(8).fill().map(()=>new L),this.satAxes=new Array(3).fill().map(()=>new L),this.satBounds=new Array(3).fill().map(()=>new rt),this.alignedSatBounds=new Array(3).fill().map(()=>new rt),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}O.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,n=this.points;for(let h=0;h<=1;h++)for(let u=0;u<=1;u++)for(let f=0;f<=1;f++){const l=1*h|2*u|4*f,p=n[l];p.x=h?s.x:e.x,p.y=u?s.y:e.y,p.z=f?s.z:e.z,p.applyMatrix4(t)}const o=this.satBounds,i=this.satAxes,a=n[0];for(let h=0;h<3;h++){const u=i[h],f=o[h],l=1<<h,p=n[l];u.subVectors(a,p),f.setFromPoints(u,n)}const c=this.alignedSatBounds;c[0].setFromPointsField(n,"x"),c[1].setFromPointsField(n,"y"),c[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();O.prototype.intersectsBox=function(){const r=new rt;return function(e){this.needsUpdate&&this.update();const s=e.min,n=e.max,o=this.satBounds,i=this.satAxes,a=this.alignedSatBounds;if(r.min=s.x,r.max=n.x,a[0].isSeparated(r)||(r.min=s.y,r.max=n.y,a[1].isSeparated(r))||(r.min=s.z,r.max=n.z,a[2].isSeparated(r)))return!1;for(let c=0;c<3;c++){const h=i[c],u=o[c];if(r.setFromBox(h,e),u.isSeparated(r))return!1}return!0}}();O.prototype.intersectsTriangle=function(){const r=new st,t=new Array(3),e=new rt,s=new rt,n=new L;return function(i){this.needsUpdate&&this.update(),i.isExtendedTriangle?i.needsUpdate&&i.update():(r.copy(i),r.update(),i=r);const a=this.satBounds,c=this.satAxes;t[0]=i.a,t[1]=i.b,t[2]=i.c;for(let l=0;l<3;l++){const p=a[l],g=c[l];if(e.setFromPoints(g,t),p.isSeparated(e))return!1}const h=i.satBounds,u=i.satAxes,f=this.points;for(let l=0;l<3;l++){const p=h[l],g=u[l];if(e.setFromPoints(g,f),p.isSeparated(e))return!1}for(let l=0;l<3;l++){const p=c[l];for(let g=0;g<4;g++){const w=u[g];if(n.crossVectors(p,w),e.setFromPoints(n,t),s.setFromPoints(n,f),e.isSeparated(s))return!1}}return!0}}();O.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();O.prototype.distanceToPoint=function(){const r=new L;return function(e){return this.closestPointToPoint(e,r),e.distanceTo(r)}}();O.prototype.distanceToBox=function(){const r=["x","y","z"],t=new Array(12).fill().map(()=>new et),e=new Array(12).fill().map(()=>new et),s=new L,n=new L;return function(i,a=0,c=null,h=null){if(this.needsUpdate&&this.update(),this.intersectsBox(i))return(c||h)&&(i.getCenter(n),this.closestPointToPoint(n,s),i.closestPointToPoint(s,n),c&&c.copy(s),h&&h.copy(n)),0;const u=a*a,f=i.min,l=i.max,p=this.points;let g=1/0;for(let d=0;d<8;d++){const m=p[d];n.copy(m).clamp(f,l);const y=m.distanceToSquared(n);if(y<g&&(g=y,c&&c.copy(m),h&&h.copy(n),y<u))return Math.sqrt(y)}let w=0;for(let d=0;d<3;d++)for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){const x=(d+1)%3,b=(d+2)%3,P=m<<x|y<<b,A=1<<d|m<<x|y<<b,T=p[P],S=p[A];t[w].set(T,S);const B=r[d],C=r[x],M=r[b],_=e[w],V=_.start,F=_.end;V[B]=f[B],V[C]=m?f[C]:l[C],V[M]=y?f[M]:l[C],F[B]=l[B],F[C]=m?f[C]:l[C],F[M]=y?f[M]:l[C],w++}for(let d=0;d<=1;d++)for(let m=0;m<=1;m++)for(let y=0;y<=1;y++){n.x=d?l.x:f.x,n.y=m?l.y:f.y,n.z=y?l.z:f.z,this.closestPointToPoint(n,s);const x=n.distanceToSquared(s);if(x<g&&(g=x,c&&c.copy(s),h&&h.copy(n),x<u))return Math.sqrt(x)}for(let d=0;d<12;d++){const m=t[d];for(let y=0;y<12;y++){const x=e[y];Ze(m,x,s,n);const b=s.distanceToSquared(n);if(b<g&&(g=b,c&&c.copy(s),h&&h.copy(n),b<u))return Math.sqrt(b)}}return Math.sqrt(g)}}();class Ke{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class mi extends Ke{constructor(){super(()=>new st)}}const K=new mi;class yi{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=s=>{e&&t.push(e),e=s,this.float32Array=new Float32Array(s),this.uint16Array=new Uint16Array(s),this.uint32Array=new Uint32Array(s)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,t.length!==0&&this.setBuffer(t.pop())}}}const R=new yi;let ft,Bt;const At=[],ee=new Ke(()=>new G);function gi(r,t,e,s,n,o){ft=ee.getPrimitive(),Bt=ee.getPrimitive(),At.push(ft,Bt),R.setBuffer(r._roots[t]);const i=Oe(0,r.geometry,e,s,n,o);R.clearBuffer(),ee.releasePrimitive(ft),ee.releasePrimitive(Bt),At.pop(),At.pop();const a=At.length;return a>0&&(Bt=At[a-1],ft=At[a-2]),i}function Oe(r,t,e,s,n=null,o=0,i=0){const{float32Array:a,uint16Array:c,uint32Array:h}=R;let u=r*2;if($(u,c)){const l=H(r,h),p=X(u,c);return N(r,a,ft),s(l,p,!1,i,o+r,ft)}else{let B=function(M){const{uint16Array:_,uint32Array:V}=R;let F=M*2;for(;!$(F,_);)M=Y(M),F=M*2;return H(M,V)},C=function(M){const{uint16Array:_,uint32Array:V}=R;let F=M*2;for(;!$(F,_);)M=Z(M,V),F=M*2;return H(M,V)+X(F,_)};const l=Y(r),p=Z(r,h);let g=l,w=p,d,m,y,x;if(n&&(y=ft,x=Bt,N(g,a,y),N(w,a,x),d=n(y),m=n(x),m<d)){g=p,w=l;const M=d;d=m,m=M,y=x}y||(y=ft,N(g,a,y));const b=$(g*2,c),P=e(y,b,d,i+1,o+g);let A;if(P===xs){const M=B(g),V=C(g)-M;A=s(M,V,!0,i+1,o+g,y)}else A=P&&Oe(g,t,e,s,n,o,i+1);if(A)return!0;x=Bt,N(w,a,x);const T=$(w*2,c),S=e(x,T,m,i+1,o+w);let v;if(S===xs){const M=B(w),V=C(w)-M;v=s(M,V,!0,i+1,o+w,x)}else v=S&&Oe(w,t,e,s,n,o,i+1);return!!v}}const Dt=new L,Le=new L;function wi(r,t,e={},s=0,n=1/0){const o=s*s,i=n*n;let a=1/0,c=null;if(r.shapecast({boundsTraverseOrder:u=>(Dt.copy(t).clamp(u.min,u.max),Dt.distanceToSquared(t)),intersectsBounds:(u,f,l)=>l<a&&l<i,intersectsTriangle:(u,f)=>{u.closestPointToPoint(t,Dt);const l=t.distanceToSquared(Dt);return l<a&&(Le.copy(Dt),a=l,c=f),l<o}}),a===1/0)return null;const h=Math.sqrt(a);return e.point?e.point.copy(Le):e.point=Le.clone(),e.distance=h,e.faceIndex=c,e}const xi=parseInt(cn)>=169,dt=new L,mt=new L,yt=new L,se=new ht,ne=new ht,ie=new ht,Ts=new L,vs=new L,Ss=new L,Nt=new L;function Pi(r,t,e,s,n,o,i,a){let c;if(o===an?c=r.intersectTriangle(s,e,t,!0,n):c=r.intersectTriangle(t,e,s,o!==wt,n),c===null)return null;const h=r.origin.distanceTo(n);return h<i||h>a?null:{distance:h,point:n.clone()}}function Ai(r,t,e,s,n,o,i,a,c,h,u){dt.fromBufferAttribute(t,o),mt.fromBufferAttribute(t,i),yt.fromBufferAttribute(t,a);const f=Pi(r,dt,mt,yt,Nt,c,h,u);if(f){const l=new L;xt.getBarycoord(Nt,dt,mt,yt,l),s&&(se.fromBufferAttribute(s,o),ne.fromBufferAttribute(s,i),ie.fromBufferAttribute(s,a),f.uv=xt.getInterpolation(Nt,dt,mt,yt,se,ne,ie,new ht)),n&&(se.fromBufferAttribute(n,o),ne.fromBufferAttribute(n,i),ie.fromBufferAttribute(n,a),f.uv1=xt.getInterpolation(Nt,dt,mt,yt,se,ne,ie,new ht)),e&&(Ts.fromBufferAttribute(e,o),vs.fromBufferAttribute(e,i),Ss.fromBufferAttribute(e,a),f.normal=xt.getInterpolation(Nt,dt,mt,yt,Ts,vs,Ss,new L),f.normal.dot(r.direction)>0&&f.normal.multiplyScalar(-1));const p={a:o,b:i,c:a,normal:new L,materialIndex:0};xt.getNormal(dt,mt,yt,p.normal),f.face=p,f.faceIndex=o,xi&&(f.barycoord=l)}return f}function we(r,t,e,s,n,o,i){const a=s*3;let c=a+0,h=a+1,u=a+2;const f=r.index;r.index&&(c=f.getX(c),h=f.getX(h),u=f.getX(u));const{position:l,normal:p,uv:g,uv1:w}=r.attributes,d=Ai(e,l,p,g,w,c,h,u,t,o,i);return d?(d.faceIndex=s,n&&n.push(d),d):null}function j(r,t,e,s){const n=r.a,o=r.b,i=r.c;let a=t,c=t+1,h=t+2;e&&(a=e.getX(a),c=e.getX(c),h=e.getX(h)),n.x=s.getX(a),n.y=s.getY(a),n.z=s.getZ(a),o.x=s.getX(c),o.y=s.getY(c),o.z=s.getZ(c),i.x=s.getX(h),i.y=s.getY(h),i.z=s.getZ(h)}function bi(r,t,e,s,n,o,i,a){const{geometry:c,_indirectBuffer:h}=r;for(let u=s,f=s+n;u<f;u++)we(c,t,e,u,o,i,a)}function Mi(r,t,e,s,n,o,i){const{geometry:a,_indirectBuffer:c}=r;let h=1/0,u=null;for(let f=s,l=s+n;f<l;f++){let p;p=we(a,t,e,f,null,o,i),p&&p.distance<h&&(u=p,h=p.distance)}return u}function Ti(r,t,e,s,n,o,i){const{geometry:a}=e,{index:c}=a,h=a.attributes.position;for(let u=r,f=t+r;u<f;u++){let l;if(l=u,j(i,l*3,c,h),i.needsUpdate=!0,s(i,l,n,o))return!0}return!1}function vi(r,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=r.geometry,s=e.index?e.index.array:null,n=e.attributes.position;let o,i,a,c,h=0;const u=r._roots;for(let l=0,p=u.length;l<p;l++)o=u[l],i=new Uint32Array(o),a=new Uint16Array(o),c=new Float32Array(o),f(0,h),h+=o.byteLength;function f(l,p,g=!1){const w=l*2;if(a[w+15]===ge){const m=i[l+6],y=a[w+14];let x=1/0,b=1/0,P=1/0,A=-1/0,T=-1/0,S=-1/0;for(let v=3*m,B=3*(m+y);v<B;v++){let C=s[v];const M=n.getX(C),_=n.getY(C),V=n.getZ(C);M<x&&(x=M),M>A&&(A=M),_<b&&(b=_),_>T&&(T=_),V<P&&(P=V),V>S&&(S=V)}return c[l+0]!==x||c[l+1]!==b||c[l+2]!==P||c[l+3]!==A||c[l+4]!==T||c[l+5]!==S?(c[l+0]=x,c[l+1]=b,c[l+2]=P,c[l+3]=A,c[l+4]=T,c[l+5]=S,!0):!1}else{const m=l+8,y=i[l+6],x=m+p,b=y+p;let P=g,A=!1,T=!1;t?P||(A=t.has(x),T=t.has(b),P=!A&&!T):(A=!0,T=!0);const S=P||A,v=P||T;let B=!1;S&&(B=f(m,p,P));let C=!1;v&&(C=f(y,p,P));const M=B||C;if(M)for(let _=0;_<3;_++){const V=m+_,F=y+_,z=c[V],D=c[V+3],U=c[F],nt=c[F+3];c[l+_]=z<U?z:U,c[l+_+3]=D>nt?D:nt}return M}}}function pt(r,t,e,s,n){let o,i,a,c,h,u;const f=1/e.direction.x,l=1/e.direction.y,p=1/e.direction.z,g=e.origin.x,w=e.origin.y,d=e.origin.z;let m=t[r],y=t[r+3],x=t[r+1],b=t[r+3+1],P=t[r+2],A=t[r+3+2];return f>=0?(o=(m-g)*f,i=(y-g)*f):(o=(y-g)*f,i=(m-g)*f),l>=0?(a=(x-w)*l,c=(b-w)*l):(a=(b-w)*l,c=(x-w)*l),o>c||a>i||((a>o||isNaN(o))&&(o=a),(c<i||isNaN(i))&&(i=c),p>=0?(h=(P-d)*p,u=(A-d)*p):(h=(A-d)*p,u=(P-d)*p),o>u||h>i)?!1:((h>o||o!==o)&&(o=h),(u<i||i!==i)&&(i=u),o<=n&&i>=s)}function Si(r,t,e,s,n,o,i,a){const{geometry:c,_indirectBuffer:h}=r;for(let u=s,f=s+n;u<f;u++){let l=h?h[u]:u;we(c,t,e,l,o,i,a)}}function _i(r,t,e,s,n,o,i){const{geometry:a,_indirectBuffer:c}=r;let h=1/0,u=null;for(let f=s,l=s+n;f<l;f++){let p;p=we(a,t,e,c?c[f]:f,null,o,i),p&&p.distance<h&&(u=p,h=p.distance)}return u}function Bi(r,t,e,s,n,o,i){const{geometry:a}=e,{index:c}=a,h=a.attributes.position;for(let u=r,f=t+r;u<f;u++){let l;if(l=e.resolveTriangleIndex(u),j(i,l*3,c,h),i.needsUpdate=!0,s(i,l,n,o))return!0}return!1}function Li(r,t,e,s,n,o,i){R.setBuffer(r._roots[t]),$e(0,r,e,s,n,o,i),R.clearBuffer()}function $e(r,t,e,s,n,o,i){const{float32Array:a,uint16Array:c,uint32Array:h}=R,u=r*2;if($(u,c)){const l=H(r,h),p=X(u,c);bi(t,e,s,l,p,n,o,i)}else{const l=Y(r);pt(l,a,s,o,i)&&$e(l,t,e,s,n,o,i);const p=Z(r,h);pt(p,a,s,o,i)&&$e(p,t,e,s,n,o,i)}}const Ei=["x","y","z"];function Ci(r,t,e,s,n,o){R.setBuffer(r._roots[t]);const i=He(0,r,e,s,n,o);return R.clearBuffer(),i}function He(r,t,e,s,n,o){const{float32Array:i,uint16Array:a,uint32Array:c}=R;let h=r*2;if($(h,a)){const f=H(r,c),l=X(h,a);return Mi(t,e,s,f,l,n,o)}else{const f=Us(r,c),l=Ei[f],g=s.direction[l]>=0;let w,d;g?(w=Y(r),d=Z(r,c)):(w=Z(r,c),d=Y(r));const y=pt(w,i,s,n,o)?He(w,t,e,s,n,o):null;if(y){const P=y.point[l];if(g?P<=i[d+f]:P>=i[d+f+3])return y}const b=pt(d,i,s,n,o)?He(d,t,e,s,n,o):null;return y&&b?y.distance<=b.distance?y:b:y||b||null}}const oe=new G,bt=new st,Mt=new st,jt=new ot,_s=new O,re=new O;function Vi(r,t,e,s){R.setBuffer(r._roots[t]);const n=Ge(0,r,e,s);return R.clearBuffer(),n}function Ge(r,t,e,s,n=null){const{float32Array:o,uint16Array:i,uint32Array:a}=R;let c=r*2;if(n===null&&(e.boundingBox||e.computeBoundingBox(),_s.set(e.boundingBox.min,e.boundingBox.max,s),n=_s),$(c,i)){const u=t.geometry,f=u.index,l=u.attributes.position,p=e.index,g=e.attributes.position,w=H(r,a),d=X(c,i);if(jt.copy(s).invert(),e.boundsTree)return N(r,o,re),re.matrix.copy(jt),re.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:y=>re.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let x=w*3,b=(d+w)*3;x<b;x+=3)if(j(Mt,x,f,l),Mt.needsUpdate=!0,y.intersectsTriangle(Mt))return!0;return!1}});for(let m=w*3,y=(d+w)*3;m<y;m+=3){j(bt,m,f,l),bt.a.applyMatrix4(jt),bt.b.applyMatrix4(jt),bt.c.applyMatrix4(jt),bt.needsUpdate=!0;for(let x=0,b=p.count;x<b;x+=3)if(j(Mt,x,p,g),Mt.needsUpdate=!0,bt.intersectsTriangle(Mt))return!0}}else{const u=r+8,f=a[r+6];return N(u,o,oe),!!(n.intersectsBox(oe)&&Ge(u,t,e,s,n)||(N(f,o,oe),n.intersectsBox(oe)&&Ge(f,t,e,s,n)))}}const ae=new ot,Ee=new O,Ut=new O,Fi=new L,zi=new L,Ri=new L,Ii=new L;function Di(r,t,e,s={},n={},o=0,i=1/0){t.boundingBox||t.computeBoundingBox(),Ee.set(t.boundingBox.min,t.boundingBox.max,e),Ee.needsUpdate=!0;const a=r.geometry,c=a.attributes.position,h=a.index,u=t.attributes.position,f=t.index,l=K.getPrimitive(),p=K.getPrimitive();let g=Fi,w=zi,d=null,m=null;n&&(d=Ri,m=Ii);let y=1/0,x=null,b=null;return ae.copy(e).invert(),Ut.matrix.copy(ae),r.shapecast({boundsTraverseOrder:P=>Ee.distanceToBox(P),intersectsBounds:(P,A,T)=>T<y&&T<i?(A&&(Ut.min.copy(P.min),Ut.max.copy(P.max),Ut.needsUpdate=!0),!0):!1,intersectsRange:(P,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:S=>Ut.distanceToBox(S),intersectsBounds:(S,v,B)=>B<y&&B<i,intersectsRange:(S,v)=>{for(let B=S,C=S+v;B<C;B++){j(p,3*B,f,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let M=P,_=P+A;M<_;M++){j(l,3*M,h,c),l.needsUpdate=!0;const V=l.distanceToTriangle(p,g,d);if(V<y&&(w.copy(g),m&&m.copy(d),y=V,x=M,b=B),V<o)return!0}}}});{const T=Vt(t);for(let S=0,v=T;S<v;S++){j(p,3*S,f,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let B=P,C=P+A;B<C;B++){j(l,3*B,h,c),l.needsUpdate=!0;const M=l.distanceToTriangle(p,g,d);if(M<y&&(w.copy(g),m&&m.copy(d),y=M,x=B,b=S),M<o)return!0}}}}}),K.releasePrimitive(l),K.releasePrimitive(p),y===1/0?null:(s.point?s.point.copy(w):s.point=w.clone(),s.distance=y,s.faceIndex=x,n&&(n.point?n.point.copy(m):n.point=m.clone(),n.point.applyMatrix4(ae),w.applyMatrix4(ae),n.distance=w.sub(n.point).length(),n.faceIndex=b),s)}function Ni(r,t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=r.geometry,s=e.index?e.index.array:null,n=e.attributes.position;let o,i,a,c,h=0;const u=r._roots;for(let l=0,p=u.length;l<p;l++)o=u[l],i=new Uint32Array(o),a=new Uint16Array(o),c=new Float32Array(o),f(0,h),h+=o.byteLength;function f(l,p,g=!1){const w=l*2;if(a[w+15]===ge){const m=i[l+6],y=a[w+14];let x=1/0,b=1/0,P=1/0,A=-1/0,T=-1/0,S=-1/0;for(let v=m,B=m+y;v<B;v++){const C=3*r.resolveTriangleIndex(v);for(let M=0;M<3;M++){let _=C+M;_=s?s[_]:_;const V=n.getX(_),F=n.getY(_),z=n.getZ(_);V<x&&(x=V),V>A&&(A=V),F<b&&(b=F),F>T&&(T=F),z<P&&(P=z),z>S&&(S=z)}}return c[l+0]!==x||c[l+1]!==b||c[l+2]!==P||c[l+3]!==A||c[l+4]!==T||c[l+5]!==S?(c[l+0]=x,c[l+1]=b,c[l+2]=P,c[l+3]=A,c[l+4]=T,c[l+5]=S,!0):!1}else{const m=l+8,y=i[l+6],x=m+p,b=y+p;let P=g,A=!1,T=!1;t?P||(A=t.has(x),T=t.has(b),P=!A&&!T):(A=!0,T=!0);const S=P||A,v=P||T;let B=!1;S&&(B=f(m,p,P));let C=!1;v&&(C=f(y,p,P));const M=B||C;if(M)for(let _=0;_<3;_++){const V=m+_,F=y+_,z=c[V],D=c[V+3],U=c[F],nt=c[F+3];c[l+_]=z<U?z:U,c[l+_+3]=D>nt?D:nt}return M}}}function ji(r,t,e,s,n,o,i){R.setBuffer(r._roots[t]),qe(0,r,e,s,n,o,i),R.clearBuffer()}function qe(r,t,e,s,n,o,i){const{float32Array:a,uint16Array:c,uint32Array:h}=R,u=r*2;if($(u,c)){const l=H(r,h),p=X(u,c);Si(t,e,s,l,p,n,o,i)}else{const l=Y(r);pt(l,a,s,o,i)&&qe(l,t,e,s,n,o,i);const p=Z(r,h);pt(p,a,s,o,i)&&qe(p,t,e,s,n,o,i)}}const Ui=["x","y","z"];function ki(r,t,e,s,n,o){R.setBuffer(r._roots[t]);const i=We(0,r,e,s,n,o);return R.clearBuffer(),i}function We(r,t,e,s,n,o){const{float32Array:i,uint16Array:a,uint32Array:c}=R;let h=r*2;if($(h,a)){const f=H(r,c),l=X(h,a);return _i(t,e,s,f,l,n,o)}else{const f=Us(r,c),l=Ui[f],g=s.direction[l]>=0;let w,d;g?(w=Y(r),d=Z(r,c)):(w=Z(r,c),d=Y(r));const y=pt(w,i,s,n,o)?We(w,t,e,s,n,o):null;if(y){const P=y.point[l];if(g?P<=i[d+f]:P>=i[d+f+3])return y}const b=pt(d,i,s,n,o)?We(d,t,e,s,n,o):null;return y&&b?y.distance<=b.distance?y:b:y||b||null}}const ce=new G,Tt=new st,vt=new st,kt=new ot,Bs=new O,le=new O;function Oi(r,t,e,s){R.setBuffer(r._roots[t]);const n=Xe(0,r,e,s);return R.clearBuffer(),n}function Xe(r,t,e,s,n=null){const{float32Array:o,uint16Array:i,uint32Array:a}=R;let c=r*2;if(n===null&&(e.boundingBox||e.computeBoundingBox(),Bs.set(e.boundingBox.min,e.boundingBox.max,s),n=Bs),$(c,i)){const u=t.geometry,f=u.index,l=u.attributes.position,p=e.index,g=e.attributes.position,w=H(r,a),d=X(c,i);if(kt.copy(s).invert(),e.boundsTree)return N(r,o,le),le.matrix.copy(kt),le.needsUpdate=!0,e.boundsTree.shapecast({intersectsBounds:y=>le.intersectsBox(y),intersectsTriangle:y=>{y.a.applyMatrix4(s),y.b.applyMatrix4(s),y.c.applyMatrix4(s),y.needsUpdate=!0;for(let x=w,b=d+w;x<b;x++)if(j(vt,3*t.resolveTriangleIndex(x),f,l),vt.needsUpdate=!0,y.intersectsTriangle(vt))return!0;return!1}});for(let m=w,y=d+w;m<y;m++){const x=t.resolveTriangleIndex(m);j(Tt,3*x,f,l),Tt.a.applyMatrix4(kt),Tt.b.applyMatrix4(kt),Tt.c.applyMatrix4(kt),Tt.needsUpdate=!0;for(let b=0,P=p.count;b<P;b+=3)if(j(vt,b,p,g),vt.needsUpdate=!0,Tt.intersectsTriangle(vt))return!0}}else{const u=r+8,f=a[r+6];return N(u,o,ce),!!(n.intersectsBox(ce)&&Xe(u,t,e,s,n)||(N(f,o,ce),n.intersectsBox(ce)&&Xe(f,t,e,s,n)))}}const ue=new ot,Ce=new O,Ot=new O,$i=new L,Hi=new L,Gi=new L,qi=new L;function Wi(r,t,e,s={},n={},o=0,i=1/0){t.boundingBox||t.computeBoundingBox(),Ce.set(t.boundingBox.min,t.boundingBox.max,e),Ce.needsUpdate=!0;const a=r.geometry,c=a.attributes.position,h=a.index,u=t.attributes.position,f=t.index,l=K.getPrimitive(),p=K.getPrimitive();let g=$i,w=Hi,d=null,m=null;n&&(d=Gi,m=qi);let y=1/0,x=null,b=null;return ue.copy(e).invert(),Ot.matrix.copy(ue),r.shapecast({boundsTraverseOrder:P=>Ce.distanceToBox(P),intersectsBounds:(P,A,T)=>T<y&&T<i?(A&&(Ot.min.copy(P.min),Ot.max.copy(P.max),Ot.needsUpdate=!0),!0):!1,intersectsRange:(P,A)=>{if(t.boundsTree){const T=t.boundsTree;return T.shapecast({boundsTraverseOrder:S=>Ot.distanceToBox(S),intersectsBounds:(S,v,B)=>B<y&&B<i,intersectsRange:(S,v)=>{for(let B=S,C=S+v;B<C;B++){const M=T.resolveTriangleIndex(B);j(p,3*M,f,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let _=P,V=P+A;_<V;_++){const F=r.resolveTriangleIndex(_);j(l,3*F,h,c),l.needsUpdate=!0;const z=l.distanceToTriangle(p,g,d);if(z<y&&(w.copy(g),m&&m.copy(d),y=z,x=_,b=B),z<o)return!0}}}})}else{const T=Vt(t);for(let S=0,v=T;S<v;S++){j(p,3*S,f,u),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let B=P,C=P+A;B<C;B++){const M=r.resolveTriangleIndex(B);j(l,3*M,h,c),l.needsUpdate=!0;const _=l.distanceToTriangle(p,g,d);if(_<y&&(w.copy(g),m&&m.copy(d),y=_,x=B,b=S),_<o)return!0}}}}}),K.releasePrimitive(l),K.releasePrimitive(p),y===1/0?null:(s.point?s.point.copy(w):s.point=w.clone(),s.distance=y,s.faceIndex=x,n&&(n.point?n.point.copy(m):n.point=m.clone(),n.point.applyMatrix4(ue),w.applyMatrix4(ue),n.distance=w.sub(n.point).length(),n.faceIndex=b),s)}function Xi(){return typeof SharedArrayBuffer<"u"}const Xt=new R.constructor,ye=new R.constructor,ut=new Ke(()=>new G),St=new G,_t=new G,Ve=new G,Fe=new G;let ze=!1;function Yi(r,t,e,s){if(ze)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");ze=!0;const n=r._roots,o=t._roots;let i,a=0,c=0;const h=new ot().copy(e).invert();for(let u=0,f=n.length;u<f;u++){Xt.setBuffer(n[u]),c=0;const l=ut.getPrimitive();N(0,Xt.float32Array,l),l.applyMatrix4(h);for(let p=0,g=o.length;p<g&&(ye.setBuffer(o[p]),i=Q(0,0,e,h,s,a,c,0,0,l),ye.clearBuffer(),c+=o[p].length,!i);p++);if(ut.releasePrimitive(l),Xt.clearBuffer(),a+=n[u].length,i)break}return ze=!1,i}function Q(r,t,e,s,n,o=0,i=0,a=0,c=0,h=null,u=!1){let f,l;u?(f=ye,l=Xt):(f=Xt,l=ye);const p=f.float32Array,g=f.uint32Array,w=f.uint16Array,d=l.float32Array,m=l.uint32Array,y=l.uint16Array,x=r*2,b=t*2,P=$(x,w),A=$(b,y);let T=!1;if(A&&P)u?T=n(H(t,m),X(t*2,y),H(r,g),X(r*2,w),c,i+t,a,o+r):T=n(H(r,g),X(r*2,w),H(t,m),X(t*2,y),a,o+r,c,i+t);else if(A){const S=ut.getPrimitive();N(t,d,S),S.applyMatrix4(e);const v=Y(r),B=Z(r,g);N(v,p,St),N(B,p,_t);const C=S.intersectsBox(St),M=S.intersectsBox(_t);T=C&&Q(t,v,s,e,n,i,o,c,a+1,S,!u)||M&&Q(t,B,s,e,n,i,o,c,a+1,S,!u),ut.releasePrimitive(S)}else{const S=Y(t),v=Z(t,m);N(S,d,Ve),N(v,d,Fe);const B=h.intersectsBox(Ve),C=h.intersectsBox(Fe);if(B&&C)T=Q(r,S,e,s,n,o,i,a,c+1,h,u)||Q(r,v,e,s,n,o,i,a,c+1,h,u);else if(B)if(P)T=Q(r,S,e,s,n,o,i,a,c+1,h,u);else{const M=ut.getPrimitive();M.copy(Ve).applyMatrix4(e);const _=Y(r),V=Z(r,g);N(_,p,St),N(V,p,_t);const F=M.intersectsBox(St),z=M.intersectsBox(_t);T=F&&Q(S,_,s,e,n,i,o,c,a+1,M,!u)||z&&Q(S,V,s,e,n,i,o,c,a+1,M,!u),ut.releasePrimitive(M)}else if(C)if(P)T=Q(r,v,e,s,n,o,i,a,c+1,h,u);else{const M=ut.getPrimitive();M.copy(Fe).applyMatrix4(e);const _=Y(r),V=Z(r,g);N(_,p,St),N(V,p,_t);const F=M.intersectsBox(St),z=M.intersectsBox(_t);T=F&&Q(v,_,s,e,n,i,o,c,a+1,M,!u)||z&&Q(v,V,s,e,n,i,o,c,a+1,M,!u),ut.releasePrimitive(M)}}return T}const fe=new O,Ls=new G,Zi={strategy:Ds,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Je{static serialize(t,e={}){e={cloneBuffers:!0,...e};const s=t.geometry,n=t._roots,o=t._indirectBuffer,i=s.getIndex();let a;return e.cloneBuffers?a={roots:n.map(c=>c.slice()),index:i?i.array.slice():null,indirectBuffer:o?o.slice():null}:a={roots:n,index:i?i.array:null,indirectBuffer:o},a}static deserialize(t,e,s={}){s={setIndex:!0,indirect:!!t.indirectBuffer,...s};const{index:n,roots:o,indirectBuffer:i}=t,a=new Je(e,{...s,[ve]:!0});if(a._roots=o,a._indirectBuffer=i||null,s.setIndex){const c=e.getIndex();if(c===null){const h=new Is(t.index,1,!1);e.setIndex(h)}else c.array!==n&&(c.array.set(n),c.needsUpdate=!0)}return a}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({...Zi,[ve]:!1},e),e.useSharedArrayBuffer&&!Xi())throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[ve]||(fi(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new G))),this.resolveTriangleIndex=e.indirect?s=>this._indirectBuffer[s]:s=>s}refit(t=null){return(this.indirect?Ni:vi)(this,t)}traverse(t,e=0){const s=this._roots[e],n=new Uint32Array(s),o=new Uint16Array(s);i(0);function i(a,c=0){const h=a*2,u=o[h+15]===ge;if(u){const f=n[a+6],l=o[h+14];t(c,u,new Float32Array(s,a*4,6),f,l)}else{const f=a+Wt/4,l=n[a+6],p=n[a+7];t(c,u,new Float32Array(s,a*4,6),p)||(i(f,c+1),i(l,c+1))}}}raycast(t,e=ns,s=0,n=1/0){const o=this._roots,i=this.geometry,a=[],c=e.isMaterial,h=Array.isArray(e),u=i.groups,f=c?e.side:e,l=this.indirect?ji:Li;for(let p=0,g=o.length;p<g;p++){const w=h?e[u[p].materialIndex].side:f,d=a.length;if(l(this,p,w,t,a,s,n),h){const m=u[p].materialIndex;for(let y=d,x=a.length;y<x;y++)a[y].face.materialIndex=m}}return a}raycastFirst(t,e=ns,s=0,n=1/0){const o=this._roots,i=this.geometry,a=e.isMaterial,c=Array.isArray(e);let h=null;const u=i.groups,f=a?e.side:e,l=this.indirect?ki:Ci;for(let p=0,g=o.length;p<g;p++){const w=c?e[u[p].materialIndex].side:f,d=l(this,p,w,t,s,n);d!=null&&(h==null||d.distance<h.distance)&&(h=d,c&&(d.face.materialIndex=u[p].materialIndex))}return h}intersectsGeometry(t,e){let s=!1;const n=this._roots,o=this.indirect?Oi:Vi;for(let i=0,a=n.length;i<a&&(s=o(this,i,t,e),!s);i++);return s}shapecast(t){const e=K.getPrimitive(),s=this.indirect?Bi:Ti;let{boundsTraverseOrder:n,intersectsBounds:o,intersectsRange:i,intersectsTriangle:a}=t;if(i&&a){const f=i;i=(l,p,g,w,d)=>f(l,p,g,w,d)?!0:s(l,p,this,a,g,w,e)}else i||(a?i=(f,l,p,g)=>s(f,l,this,a,p,g,e):i=(f,l,p)=>p);let c=!1,h=0;const u=this._roots;for(let f=0,l=u.length;f<l;f++){const p=u[f];if(c=gi(this,f,o,i,n,h),c)break;h+=p.byteLength}return K.releasePrimitive(e),c}bvhcast(t,e,s){let{intersectsRanges:n,intersectsTriangles:o}=s;const i=K.getPrimitive(),a=this.geometry.index,c=this.geometry.attributes.position,h=this.indirect?g=>{const w=this.resolveTriangleIndex(g);j(i,w*3,a,c)}:g=>{j(i,g*3,a,c)},u=K.getPrimitive(),f=t.geometry.index,l=t.geometry.attributes.position,p=t.indirect?g=>{const w=t.resolveTriangleIndex(g);j(u,w*3,f,l)}:g=>{j(u,g*3,f,l)};if(o){const g=(w,d,m,y,x,b,P,A)=>{for(let T=m,S=m+y;T<S;T++){p(T),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let v=w,B=w+d;v<B;v++)if(h(v),i.needsUpdate=!0,o(i,u,v,T,x,b,P,A))return!0}return!1};if(n){const w=n;n=function(d,m,y,x,b,P,A,T){return w(d,m,y,x,b,P,A,T)?!0:g(d,m,y,x,b,P,A,T)}}else n=g}return Yi(this,t,e,n)}intersectsBox(t,e){return fe.set(t.min,t.max,e),fe.needsUpdate=!0,this.shapecast({intersectsBounds:s=>fe.intersectsBox(s),intersectsTriangle:s=>fe.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},n={},o=0,i=1/0){return(this.indirect?Wi:Di)(this,t,e,s,n,o,i)}closestPointToPoint(t,e={},s=0,n=1/0){return wi(this,t,e,s,n)}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{N(0,new Float32Array(s),Ls),t.union(Ls)}),t}}const{lerp:gt}=ln,k=[151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];for(let r=0;r<256;r++)k[256+r]=k[r];function Re(r){return r*r*r*(r*(r*6-15)+10)}function ct(r,t,e,s){const n=r&15,o=n<8?t:e,i=n<4?e:n==12||n==14?t:s;return((n&1)==0?o:-o)+((n&2)==0?i:-i)}class Ki{noise(t,e,s){const n=Math.floor(t),o=Math.floor(e),i=Math.floor(s),a=n&255,c=o&255,h=i&255;t-=n,e-=o,s-=i;const u=t-1,f=e-1,l=s-1,p=Re(t),g=Re(e),w=Re(s),d=k[a]+c,m=k[d]+h,y=k[d+1]+h,x=k[a+1]+c,b=k[x]+h,P=k[x+1]+h;return gt(gt(gt(ct(k[m],t,e,s),ct(k[b],u,e,s),p),gt(ct(k[y],t,f,s),ct(k[P],u,f,s),p),g),gt(gt(ct(k[m+1],t,e,l),ct(k[b+1],u,e,l),p),gt(ct(k[y+1],t,f,l),ct(k[P+1],u,f,l),p),g),w)}}const Zt=class Zt{constructor(t){E(this,"assetManager");E(this,"terrainObject3D");E(this,"terrainPatches",new Map);E(this,"waterMesh");E(this,"waterLevel",-10);E(this,"populations",[]);E(this,"planeStep",{x:0,z:0});E(this,"prevPlaneStep",{x:Math.PI,z:Math.PI});this.assetManager=t,this.terrainObject3D=new un,this.terrainObject3D.position.y=-10,this.waterMesh=new W(new is(me/2,me/2,1e3,1e3),this.assetManager.waterMaterial),this.waterMesh.rotation.x=Math.PI/2}getTerrainObject3D(){return this.terrainObject3D}getWaterMesh(){return this.waterMesh}initializeInternalPopulations(){this.populations=[{group:this.assetManager.groupTree,rarity:.02,min:10,max:150,seed:1e3,scale:.5,offset:3,randRot:()=>new Lt(Math.random()*.2,Math.random()*Math.PI*2,Math.random()*.2)},{group:this.assetManager.groupPalm,rarity:.01,min:0,max:40,seed:1e3,scale:.5,offset:0,randRot:()=>new Lt(Math.random()*.2,Math.random()*Math.PI*2,Math.random()*.2)}]}handleTerrainGeneration(t){this.waterMesh.position.set(t.x,this.waterLevel,t.z),this.planeStep={x:Math.round(t.x/J),z:Math.round(t.z/J)};const e=-Math.floor(ls/J),s=Math.ceil(ls/J);if(this.planeStep.x!==this.prevPlaneStep.x||this.planeStep.z!==this.prevPlaneStep.z){const n=[e+this.planeStep.x,e+this.planeStep.z,s+this.planeStep.x,s+this.planeStep.z];this.removeTerrainBounds(...n),this.fillTerrainBounds(...n)}this.prevPlaneStep={...this.planeStep}}checkTerrainCollision(t){if(this.waterLevel>t.min.y)return!0;const e=`${this.planeStep.x},${this.planeStep.z}`,s=this.terrainPatches.get(e);return s?this.collisionCheckDetail(s,t):!1}noise(t,e){return Zt.perlin.noise(t.x,t.y,0)*e}terrainNoise(t,e,s){return this.noise(t.divideScalar(e),Tn*s)}noiseFunction(t){return this.terrainNoise(t,1,1)+this.terrainNoise(t,10,10)+this.terrainNoise(t,100,50)-5}applyTerrainNoise(t,e){const s=t.geometry.attributes.position,n=t.geometry.attributes.uv,o=new ht;for(let i=0;i<s.count;i++){o.fromBufferAttribute(n,i).add(e).multiplyScalar(vn);const a=this.noiseFunction(o);s.setZ(i,a)}s.needsUpdate=!0}applyTerrainShader(t,e){const s=a=>{const[c,h,u]=Un(a);return`vec3(${c}, ${h}, ${u})`},n="varying vec3 vPos;",o=`
      uniform float lim0;
      uniform float lim1;
      uniform float lim2;
      uniform float lim3;
      ${n}
    `,i=`
      vec3 col = vPos.y >= lim3 ? ${s(e.lim3.color)} :
                  vPos.y >= lim2 ? ${s(e.lim2.color)} :
                  vPos.y >= lim1 ? ${s(e.lim1.color)} :
                                  ${s(e.lim0.color)};
      vec4 diffuseColor = vec4(col, opacity);
    `;t.material=new $t({side:wt}),t.material.onBeforeCompile=a=>{Object.assign(a.uniforms,{lim0:e.lim0,lim1:e.lim1,lim2:e.lim2,lim3:e.lim3}),a.vertexShader=`
        ${n}
        ${a.vertexShader.replace("#include <begin_vertex>",`#include <begin_vertex>
vPos = vec3(position);`)}
      `,a.fragmentShader=`
        ${o}
        ${a.fragmentShader.replace("vec4 diffuseColor = vec4( diffuse, opacity );",i)}
      `}}addTerrain(t,e){const s=new is(J,J,us,us),n=new W(s,this.assetManager.terrainMaterial);n.receiveShadow=!0,this.applyTerrainNoise(n,new ht(t,e)),s.rotateX(Math.PI/2),n.position.set(t,0,e).multiplyScalar(J),s.computeVertexNormals(),s.boundsTree=new Je(s),this.terrainObject3D.add(n),this.terrainPatches.set(`${t},${e}`,n),this.applyTerrainShader(n,In),this.populateTerrain(n)}populateTerrain(t){for(const e of this.populations)this.populateGroupMesh(t,e)}populateGroupMesh(t,e){const s=t.geometry.attributes.position,n=[];for(let o=0;o<s.count;o++)if(Math.random()>1-e.rarity){const i=new L;if(i.fromBufferAttribute(s,o),i.y+=e.offset,i.y-e.offset>e.min&&i.y<e.max&&Zt.perlin.noise(i.x/J+e.seed,i.z/J+e.seed,0)>=-.1){const a=e.randRot(),c=Math.random()/2+.5,h=I(c,c,c).multiplyScalar(e.scale);n.push(kn(i,a,h))}}for(const o of e.group)t.add(On(o,n))}fillTerrainBounds(t,e,s,n){for(let o=t;o<=s;o++)for(let i=e;i<=n;i++)this.existsTerrain(o,i)||this.addTerrain(o,i)}existsTerrain(t,e){return this.terrainPatches.has(`${t},${e}`)}removeTerrainBounds(t,e,s,n){const o=[];for(const i of this.terrainPatches.keys()){const[a,c]=i.split(",").map(Number);(a<t||a>s||c<e||c>n)&&o.push(this.terrainPatches.get(i))}for(const i of o){this.terrainObject3D.remove(i);const a=i.position.x/J+","+i.position.z/J;this.terrainPatches.delete(a)}}collisionCheckDetail(t,e){const n=t.geometry.boundsTree,o=new ot().copy(t.matrixWorld).invert();return!!(n!=null&&n.intersectsBox(e,o))}};E(Zt,"perlin",new Ki);let Ye=Zt;const de=0,Ji=1,Qi=new L,Es=new et,Ie=new Et,Cs=new L,he=new xt;class to{constructor(){this.tolerance=-1,this.faces=[],this.newFaces=[],this.assigned=new Vs,this.unassigned=new Vs,this.vertices=[]}setFromPoints(t){if(t.length>=4){this.makeEmpty();for(let e=0,s=t.length;e<s;e++)this.vertices.push(new eo(t[e]));this._compute()}return this}setFromObject(t){const e=[];return t.updateMatrixWorld(!0),t.traverse(function(s){const n=s.geometry;if(n!==void 0){const o=n.attributes.position;if(o!==void 0)for(let i=0,a=o.count;i<a;i++){const c=new L;c.fromBufferAttribute(o,i).applyMatrix4(s.matrixWorld),e.push(c)}}}),this.setFromPoints(e)}containsPoint(t){const e=this.faces;for(let s=0,n=e.length;s<n;s++)if(e[s].distanceToPoint(t)>this.tolerance)return!1;return!0}intersectRay(t,e){const s=this.faces;let n=-1/0,o=1/0;for(let i=0,a=s.length;i<a;i++){const c=s[i],h=c.distanceToPoint(t.origin),u=c.normal.dot(t.direction);if(h>0&&u>=0)return null;const f=u!==0?-h/u:0;if(!(f<=0)&&(u>0?o=Math.min(f,o):n=Math.max(f,n),n>o))return null}return n!==-1/0?t.at(n,e):t.at(o,e),e}intersectsRay(t){return this.intersectRay(t,Qi)!==null}makeEmpty(){return this.faces=[],this.vertices=[],this}_addVertexToFace(t,e){return t.face=e,e.outside===null?this.assigned.append(t):this.assigned.insertBefore(e.outside,t),e.outside=t,this}_removeVertexFromFace(t,e){return t===e.outside&&(t.next!==null&&t.next.face===e?e.outside=t.next:e.outside=null),this.assigned.remove(t),this}_removeAllVerticesFromFace(t){if(t.outside!==null){const e=t.outside;let s=t.outside;for(;s.next!==null&&s.next.face===t;)s=s.next;return this.assigned.removeSubList(e,s),e.prev=s.next=null,t.outside=null,e}}_deleteFaceVertices(t,e){const s=this._removeAllVerticesFromFace(t);if(s!==void 0)if(e===void 0)this.unassigned.appendChain(s);else{let n=s;do{const o=n.next;e.distanceToPoint(n.point)>this.tolerance?this._addVertexToFace(n,e):this.unassigned.append(n),n=o}while(n!==null)}return this}_resolveUnassignedPoints(t){if(this.unassigned.isEmpty()===!1){let e=this.unassigned.first();do{const s=e.next;let n=this.tolerance,o=null;for(let i=0;i<t.length;i++){const a=t[i];if(a.mark===de){const c=a.distanceToPoint(e.point);if(c>n&&(n=c,o=a),n>1e3*this.tolerance)break}}o!==null&&this._addVertexToFace(e,o),e=s}while(e!==null)}return this}_computeExtremes(){const t=new L,e=new L,s=[],n=[];for(let o=0;o<3;o++)s[o]=n[o]=this.vertices[0];t.copy(this.vertices[0].point),e.copy(this.vertices[0].point);for(let o=0,i=this.vertices.length;o<i;o++){const a=this.vertices[o],c=a.point;for(let h=0;h<3;h++)c.getComponent(h)<t.getComponent(h)&&(t.setComponent(h,c.getComponent(h)),s[h]=a);for(let h=0;h<3;h++)c.getComponent(h)>e.getComponent(h)&&(e.setComponent(h,c.getComponent(h)),n[h]=a)}return this.tolerance=3*Number.EPSILON*(Math.max(Math.abs(t.x),Math.abs(e.x))+Math.max(Math.abs(t.y),Math.abs(e.y))+Math.max(Math.abs(t.z),Math.abs(e.z))),{min:s,max:n}}_computeInitialHull(){const t=this.vertices,e=this._computeExtremes(),s=e.min,n=e.max;let o=0,i=0;for(let l=0;l<3;l++){const p=n[l].point.getComponent(l)-s[l].point.getComponent(l);p>o&&(o=p,i=l)}const a=s[i],c=n[i];let h,u;o=0,Es.set(a.point,c.point);for(let l=0,p=this.vertices.length;l<p;l++){const g=t[l];if(g!==a&&g!==c){Es.closestPointToPoint(g.point,!0,Cs);const w=Cs.distanceToSquared(g.point);w>o&&(o=w,h=g)}}o=-1,Ie.setFromCoplanarPoints(a.point,c.point,h.point);for(let l=0,p=this.vertices.length;l<p;l++){const g=t[l];if(g!==a&&g!==c&&g!==h){const w=Math.abs(Ie.distanceToPoint(g.point));w>o&&(o=w,u=g)}}const f=[];if(Ie.distanceToPoint(u.point)<0){f.push(tt.create(a,c,h),tt.create(u,c,a),tt.create(u,h,c),tt.create(u,a,h));for(let l=0;l<3;l++){const p=(l+1)%3;f[l+1].getEdge(2).setTwin(f[0].getEdge(p)),f[l+1].getEdge(1).setTwin(f[p+1].getEdge(0))}}else{f.push(tt.create(a,h,c),tt.create(u,a,c),tt.create(u,c,h),tt.create(u,h,a));for(let l=0;l<3;l++){const p=(l+1)%3;f[l+1].getEdge(2).setTwin(f[0].getEdge((3-l)%3)),f[l+1].getEdge(0).setTwin(f[p+1].getEdge(1))}}for(let l=0;l<4;l++)this.faces.push(f[l]);for(let l=0,p=t.length;l<p;l++){const g=t[l];if(g!==a&&g!==c&&g!==h&&g!==u){o=this.tolerance;let w=null;for(let d=0;d<4;d++){const m=this.faces[d].distanceToPoint(g.point);m>o&&(o=m,w=this.faces[d])}w!==null&&this._addVertexToFace(g,w)}}return this}_reindexFaces(){const t=[];for(let e=0;e<this.faces.length;e++){const s=this.faces[e];s.mark===de&&t.push(s)}return this.faces=t,this}_nextVertexToAdd(){if(this.assigned.isEmpty()===!1){let t,e=0;const s=this.assigned.first().face;let n=s.outside;do{const o=s.distanceToPoint(n.point);o>e&&(e=o,t=n),n=n.next}while(n!==null&&n.face===s);return t}}_computeHorizon(t,e,s,n){this._deleteFaceVertices(s),s.mark=Ji;let o;e===null?o=e=s.getEdge(0):o=e.next;do{const i=o.twin,a=i.face;a.mark===de&&(a.distanceToPoint(t)>this.tolerance?this._computeHorizon(t,i,a,n):n.push(o)),o=o.next}while(o!==e);return this}_addAdjoiningFace(t,e){const s=tt.create(t,e.tail(),e.head());return this.faces.push(s),s.getEdge(-1).setTwin(e.twin),s.getEdge(0)}_addNewFaces(t,e){this.newFaces=[];let s=null,n=null;for(let o=0;o<e.length;o++){const i=e[o],a=this._addAdjoiningFace(t,i);s===null?s=a:a.next.setTwin(n),this.newFaces.push(a.face),n=a}return s.next.setTwin(n),this}_addVertexToHull(t){const e=[];return this.unassigned.clear(),this._removeVertexFromFace(t,t.face),this._computeHorizon(t.point,null,t.face,e),this._addNewFaces(t,e),this._resolveUnassignedPoints(this.newFaces),this}_cleanup(){return this.assigned.clear(),this.unassigned.clear(),this.newFaces=[],this}_compute(){let t;for(this._computeInitialHull();(t=this._nextVertexToAdd())!==void 0;)this._addVertexToHull(t);return this._reindexFaces(),this._cleanup(),this}}class tt{constructor(){this.normal=new L,this.midpoint=new L,this.area=0,this.constant=0,this.outside=null,this.mark=de,this.edge=null}static create(t,e,s){const n=new tt,o=new De(t,n),i=new De(e,n),a=new De(s,n);return o.next=a.prev=i,i.next=o.prev=a,a.next=i.prev=o,n.edge=o,n.compute()}getEdge(t){let e=this.edge;for(;t>0;)e=e.next,t--;for(;t<0;)e=e.prev,t++;return e}compute(){const t=this.edge.tail(),e=this.edge.head(),s=this.edge.next.head();return he.set(t.point,e.point,s.point),he.getNormal(this.normal),he.getMidpoint(this.midpoint),this.area=he.getArea(),this.constant=this.normal.dot(this.midpoint),this}distanceToPoint(t){return this.normal.dot(t)-this.constant}}class De{constructor(t,e){this.vertex=t,this.prev=null,this.next=null,this.twin=null,this.face=e}head(){return this.vertex}tail(){return this.prev?this.prev.vertex:null}length(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceTo(t.point):-1}lengthSquared(){const t=this.head(),e=this.tail();return e!==null?e.point.distanceToSquared(t.point):-1}setTwin(t){return this.twin=t,t.twin=this,this}}class eo{constructor(t){this.point=t,this.prev=null,this.next=null,this.face=null}}class Vs{constructor(){this.head=null,this.tail=null}first(){return this.head}last(){return this.tail}clear(){return this.head=this.tail=null,this}insertBefore(t,e){return e.prev=t.prev,e.next=t,e.prev===null?this.head=e:e.prev.next=e,t.prev=e,this}insertAfter(t,e){return e.prev=t,e.next=t.next,e.next===null?this.tail=e:e.next.prev=e,t.next=e,this}append(t){return this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail,t.next=null,this.tail=t,this}appendChain(t){for(this.head===null?this.head=t:this.tail.next=t,t.prev=this.tail;t.next!==null;)t=t.next;return this.tail=t,this}remove(t){return t.prev===null?this.head=t.next:t.prev.next=t.next,t.next===null?this.tail=t.prev:t.next.prev=t.prev,this}removeSubList(t,e){return t.prev===null?this.head=e.next:t.prev.next=e.next,e.next===null?this.tail=t.prev:e.next.prev=t.prev,this}isEmpty(){return this.head===null}}class Fs extends Ne{constructor(t=[]){super();const e=[],s=[],o=new to().setFromPoints(t).faces;for(let i=0;i<o.length;i++){const a=o[i];let c=a.edge;do{const h=c.head().point;e.push(h.x,h.y,h.z),s.push(a.normal.x,a.normal.y,a.normal.z),c=c.next}while(c!==a.edge)}this.setAttribute("position",new lt(e,3)),this.setAttribute("normal",new lt(s,3))}}const so=new L;class Yt{constructor(t=1.4,e=1e-4){this.minSizeForBreak=t,this.smallDelta=e,this.tempLine1=new et,this.tempPlane1=new Et,this.tempPlane2=new Et,this.tempPlane_Cut=new Et,this.tempCM1=new L,this.tempCM2=new L,this.tempVector3=new L,this.tempVector3_2=new L,this.tempVector3_3=new L,this.tempVector3_P0=new L,this.tempVector3_P1=new L,this.tempVector3_P2=new L,this.tempVector3_N0=new L,this.tempVector3_N1=new L,this.tempVector3_AB=new L,this.tempVector3_CB=new L,this.tempResultObjects={object1:null,object2:null},this.segments=[];const s=30*30;for(let n=0;n<s;n++)this.segments[n]=!1}prepareBreakableObject(t,e,s,n,o){const i=t.userData;i.mass=e,i.velocity=s.clone(),i.angularVelocity=n.clone(),i.breakable=o}subdivideByImpact(t,e,s,n,o){const i=[],a=this.tempPlane1,c=this.tempPlane2;this.tempVector3.addVectors(e,s),a.setFromCoplanarPoints(e,t.position,this.tempVector3);const h=o+n,u=this;function f(l,p,g,w){if(Math.random()<w*.05||w>h){i.push(l);return}let d=Math.PI;w===0?(c.normal.copy(a.normal),c.constant=a.constant):w<=n?(d=(g-p)*(.2+.6*Math.random())+p,u.tempVector3_2.copy(t.position).sub(e).applyAxisAngle(s,d).add(e),c.setFromCoplanarPoints(e,u.tempVector3,u.tempVector3_2)):(d=(.5*(w&1)+.2*(2-Math.random()))*Math.PI,u.tempVector3_2.copy(e).sub(l.position).applyAxisAngle(s,d).add(l.position),u.tempVector3_3.copy(s).add(l.position),c.setFromCoplanarPoints(l.position,u.tempVector3_3,u.tempVector3_2)),u.cutByPlane(l,c,u.tempResultObjects);const m=u.tempResultObjects.object1,y=u.tempResultObjects.object2;m&&f(m,p,d,w+1),y&&f(y,d,g,w+1)}return f(t,0,2*Math.PI,0),i}cutByPlane(t,e,s){const n=t.geometry,o=n.attributes.position.array,i=n.attributes.normal.array,a=o.length/3;let c=a/3,h=n.getIndex();h&&(h=h.array,c=h.length/3);function u(M,_){const V=M*3+_;return h?h[V]:V}const f=[],l=[],p=this.smallDelta,g=a*a;for(let M=0;M<g;M++)this.segments[M]=!1;const w=this.tempVector3_P0,d=this.tempVector3_P1,m=this.tempVector3_N0,y=this.tempVector3_N1;for(let M=0;M<c-1;M++){const _=u(M,0),V=u(M,1),F=u(M,2);m.set(i[_],i[_]+1,i[_]+2);for(let z=M+1;z<c;z++){const D=u(z,0),U=u(z,1),nt=u(z,2);y.set(i[D],i[D]+1,i[D]+2),1-m.dot(y)<p&&(_===D||_===U||_===nt?V===D||V===U||V===nt?(this.segments[_*a+V]=!0,this.segments[V*a+_]=!0):(this.segments[F*a+_]=!0,this.segments[_*a+F]=!0):(V===D||V===U||V===nt)&&(this.segments[F*a+V]=!0,this.segments[V*a+F]=!0))}}const x=this.tempPlane_Cut;t.updateMatrix(),Yt.transformPlaneToLocalSpace(e,t.matrix,x);for(let M=0;M<c;M++){const _=u(M,0),V=u(M,1),F=u(M,2);for(let z=0;z<3;z++){const D=z===0?_:z===1?V:F,U=z===0?V:z===1?F:_;if(this.segments[D*a+U])continue;this.segments[D*a+U]=!0,this.segments[U*a+D]=!0,w.set(o[3*D],o[3*D+1],o[3*D+2]),d.set(o[3*U],o[3*U+1],o[3*U+2]);let Pt=0,Ft=x.distanceToPoint(w);Ft>p?(Pt=2,l.push(w.clone())):Ft<-p?(Pt=1,f.push(w.clone())):(Pt=3,f.push(w.clone()),l.push(w.clone()));let zt=0;if(Ft=x.distanceToPoint(d),Ft>p?(zt=2,l.push(d.clone())):Ft<-p?(zt=1,f.push(d.clone())):(zt=3,f.push(d.clone()),l.push(d.clone())),Pt===1&&zt===2||Pt===2&&zt===1){this.tempLine1.start.copy(w),this.tempLine1.end.copy(d);let Rt=new L;if(Rt=x.intersectLine(this.tempLine1,Rt),Rt===null)return console.error("Internal error: segment does not intersect plane."),s.segmentedObject1=null,s.segmentedObject2=null,0;f.push(Rt),l.push(Rt.clone())}}}const b=t.userData.mass*.5;this.tempCM1.set(0,0,0);let P=0;const A=f.length;if(A>0){for(let M=0;M<A;M++)this.tempCM1.add(f[M]);this.tempCM1.divideScalar(A);for(let M=0;M<A;M++){const _=f[M];_.sub(this.tempCM1),P=Math.max(P,_.x,_.y,_.z)}this.tempCM1.add(t.position)}this.tempCM2.set(0,0,0);let T=0;const S=l.length;if(S>0){for(let M=0;M<S;M++)this.tempCM2.add(l[M]);this.tempCM2.divideScalar(S);for(let M=0;M<S;M++){const _=l[M];_.sub(this.tempCM2),T=Math.max(T,_.x,_.y,_.z)}this.tempCM2.add(t.position)}let v=null,B=null,C=0;return A>4&&(v=new W(new Fs(f),t.material),v.position.copy(this.tempCM1),v.quaternion.copy(t.quaternion),this.prepareBreakableObject(v,b,t.userData.velocity,t.userData.angularVelocity,2*P>this.minSizeForBreak),C++),S>4&&(B=new W(new Fs(l),t.material),B.position.copy(this.tempCM2),B.quaternion.copy(t.quaternion),this.prepareBreakableObject(B,b,t.userData.velocity,t.userData.angularVelocity,2*T>this.minSizeForBreak),C++),s.object1=v,s.object2=B,C}static transformFreeVector(t,e){const s=t.x,n=t.y,o=t.z,i=e.elements;return t.x=i[0]*s+i[4]*n+i[8]*o,t.y=i[1]*s+i[5]*n+i[9]*o,t.z=i[2]*s+i[6]*n+i[10]*o,t}static transformFreeVectorInverse(t,e){const s=t.x,n=t.y,o=t.z,i=e.elements;return t.x=i[0]*s+i[1]*n+i[2]*o,t.y=i[4]*s+i[5]*n+i[6]*o,t.z=i[8]*s+i[9]*n+i[10]*o,t}static transformTiedVectorInverse(t,e){const s=t.x,n=t.y,o=t.z,i=e.elements;return t.x=i[0]*s+i[1]*n+i[2]*o-i[12],t.y=i[4]*s+i[5]*n+i[6]*o-i[13],t.z=i[8]*s+i[9]*n+i[10]*o-i[14],t}static transformPlaneToLocalSpace(t,e,s){s.normal.copy(t.normal),s.constant=t.constant;const n=Yt.transformTiedVectorInverse(t.coplanarPoint(so),e);Yt.transformFreeVectorInverse(s.normal,e),s.constant=-n.dot(s.normal)}}const $s=new Yt;function no(r,t,e,s,n,o){const i=new G().setFromObject(r);!o.crashed&&n.checkTerrainCollision(i)&&Hs(r,t,e,s,!0,o);for(let a=o.shards.length-1;a>=0;a--){const c=o.shards[a];c.gVel-=.001,c.rotateX(c.cDir.x),c.rotateY(c.cDir.y),c.rotateZ(c.cDir.z),c.cDir.x*=.995,c.cDir.y*=.995,c.cDir.z*=.995,c.position.x+=c.cVel.x,c.position.y+=c.cVel.y+c.gVel,c.position.z+=c.cVel.z,c.time++,c.time>500&&(e.remove(c),o.shards.splice(a,1))}}function Hs(r,t,e,s,n,o){if(o.crashed)return;const i=I(1,.5,1),a=I(0,100,0),c=$s.subdivideByImpact(t,i,a,1,5),h=()=>Math.random()*.1,u=()=>Math.random()*.5;o.clearShards();for(let f of c){const l=f;t.updateWorldMatrix(!0,!1),l.position.set(...je(t.localToWorld(t.position.clone()))),e.add(l),l.cDir=I(h(),h(),h()),l.cVel=I(u(),u(),u()),l.gVel=.01,l.time=0,o.addShard(l)}o.shards.length>0&&(o.shards[0].cVel.y=.3),e.remove(r),o.setCrashed(!0),o.shards.length>0&&(s.position.set(0,0,0),o.shards[0].add(s)),setTimeout(()=>{document.getElementById("blackout").classList.remove("left"),document.getElementById("blackout").classList.remove("right"),setTimeout(()=>window.location.replace("/flight_ended.html"),1500)},3e3)}var Gt=(r=>(r[r.DOGFIGHT=0]="DOGFIGHT",r[r.FREEFLIGHT=1]="FREEFLIGHT",r))(Gt||{});class io{constructor(){E(this,"assetManager");E(this,"soundManager");E(this,"inputManager");E(this,"cameraManager");E(this,"terrainManager");E(this,"playerPlane");E(this,"stand");E(this,"activeProjectiles",[]);E(this,"shards",[]);E(this,"flying",!1);E(this,"mode",Gt.DOGFIGHT);E(this,"players",[]);E(this,"prev",-1);E(this,"crashed",!1);E(this,"scene");E(this,"renderer");E(this,"dirLight");E(this,"stats");E(this,"ammoCountEl",document.getElementById("ammo-count"));E(this,"menuEl",document.getElementById("menu"));E(this,"blackoutEl",document.getElementById("blackout"));E(this,"loadingEl",document.getElementById("loading"));E(this,"waitingEl",document.getElementById("waiting"));E(this,"ammoEl",document.getElementById("ammo"));E(this,"freeButtonEl",document.getElementById("freeflight"));E(this,"headingEl",document.getElementsByClassName("heading")[0]);E(this,"selectEl",document.getElementsByClassName("select")[0]);E(this,"onWindowResize",()=>{const t=window.innerWidth,e=window.innerHeight;this.renderer.setSize(t,e),this.cameraManager.handleResize(t,e)});E(this,"animate",()=>{if(this.stats.begin(),requestAnimationFrame(this.animate),this.flying){this.prev<0&&(this.prev=performance.now()-gs);const t=Math.floor((performance.now()-this.prev)/gs);if(t>1e3)this.prev=performance.now();else for(let e=0;e<t;e++){if(this.cameraManager.update(this.playerPlane,this.dirLight),this.inputManager.keyPressed(" ")){const n=this.cameraManager.getBaseLocalPosition(),o=this.playerPlane.fire(this.scene,n);this.activeProjectiles.push(...o),o.length>0&&this.ammoCountEl&&(this.soundManager.playShootingSound(this.playerPlane.mesh),this.ammoCountEl.innerText=this.playerPlane.getAmmo().toString())}this._updateActiveProjectiles(),no(this.playerPlane.mesh,this.playerPlane.collider,this.scene,this.cameraManager.getThreeCamera(),this.terrainManager,this),this.playerPlane.updatePhysics(),this.inputManager.handlePlaneKeys(this.playerPlane);const s=this.playerPlane.vel.local.length();this.soundManager.updatePlaneSound(s,this.playerPlane.mesh),this.mode===Gt.FREEFLIGHT&&this.terrainManager.handleTerrainGeneration(this.playerPlane.getPosition()),this.prev=performance.now()}}else this.staticUpdate();this.renderer.render(this.scene,this.cameraManager.getThreeCamera()),this.stats.end()});const t=window.innerWidth,e=window.innerHeight;this.assetManager=new jn,this.inputManager=new Hn,this.cameraManager=new $n(t,e),this.terrainManager=new Ye(this.assetManager),this.soundManager=new Wn(this.cameraManager.getThreeCamera()),this.scene=new fn,this.scene.background=new zs(_n),this.scene.fog=new hn(this.scene.background,me*.5,me),this.renderer=new pn({logarithmicDepthBuffer:!0}),this.renderer.setSize(t,e),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=dn,document.body.appendChild(this.renderer.domElement),this.dirLight=new mn(16777215,3),this.dirLight.position.set(1,1,1),this.dirLight.target.position.set(0,0,0),this.dirLight.castShadow=!0,this.dirLight.shadow.bias=-.01,this.dirLight.shadow.mapSize.width=2**13,this.dirLight.shadow.mapSize.height=2**13;const s=100;this.dirLight.shadow.camera.left=-100,this.dirLight.shadow.camera.right=s,this.dirLight.shadow.camera.top=s,this.dirLight.shadow.camera.bottom=-100,this.dirLight.shadow.camera.near=0,this.dirLight.shadow.camera.far=100;const n=new yn(Bn,3);this.scene.add(this.dirLight,this.dirLight.target,n,this.terrainManager.getTerrainObject3D(),this.terrainManager.getWaterMesh()),window.addEventListener("resize",this.onWindowResize),this.stand=new W(new gn(1,1,2,32),this.assetManager.standMaterial)}async initializeApp(){this.stats=new qt,this.stats.dom.style.visibility="hidden",document.body.appendChild(this.stats.dom);try{if(await this.assetManager.loadAllAssets(),await this.soundManager.loadAllSounds(),this.terrainManager.initializeInternalPopulations(),this.assetManager.planeMesh&&this.assetManager.planeMaterial){const t=this.assetManager.planeMesh.clone();this.playerPlane=new qn(t,this.assetManager),this.scene.add(this.playerPlane.mesh),this.ammoCountEl&&(this.ammoCountEl.innerText=this.playerPlane.getAmmo().toString())}else throw new Error("CRITICAL: Player plane assets not loaded.");this.inputManager.setupGlobalInputListeners(),this.staticScene(),this.animate(),this.freeButtonEl&&(this.freeButtonEl.onclick=()=>this.enter(Gt.FREEFLIGHT))}catch(t){console.error("Failed to initialize the application:",t),this.loadingEl&&(this.loadingEl.innerText="Error loading assets. Please refresh.")}}initGame(){this.menuEl&&(this.menuEl.style.display="none"),this.blackoutEl&&this.blackoutEl.classList.add("right"),this.loadingEl&&this.loadingEl.classList.remove("active"),this.waitingEl&&this.waitingEl.classList.remove("active"),this.playerPlane.setPosition(I(0,5,0)),this.playerPlane.setRotation(new Lt(0,0,0)),this.playerPlane.vel.local.z=-.1,this.playerPlane.mesh.add(this.cameraManager.getThreeCamera()),$s.prepareBreakableObject(this.playerPlane.collider,1,I(0,0,0),I(0,0,0),!0),this.flying=!0,this.ammoEl&&this.ammoEl.classList.add("active")}staticScene(){this.menuEl&&(this.menuEl.style.display="flex"),this.blackoutEl&&this.blackoutEl.classList.add("left");const t=I(145,-2,0),e=this.cameraManager.getThreeCamera();this.cameraManager.setPosition(I(-1,.5,2).add(t)),this.cameraManager.setRotation(new Lt(0,-.1,0)),this.playerPlane.setRotation(new Lt(...Ct(I(e.rotation.x,e.rotation.y,e.rotation.z),I(-.1,Math.PI*.75,.1)))),this.playerPlane.mesh.remove(e),this.playerPlane.setPosition(I(0,0,0).add(t)),this.stand.position.set(...Ct(this.playerPlane.getPosition(),I(0,-1.45,0))),this.stand.castShadow=!0,this.stand.receiveShadow=!0,this.scene.add(this.stand);const s=this.playerPlane.getPosition();this.dirLight.target.position.set(s.x,10,s.z),this.dirLight.position.set(...Ct(this.dirLight.target.position,I(1,1,1))),this.terrainManager.handleTerrainGeneration(s),this.cameraManager.updateSavePosition()}staticUpdate(){const t=this.inputManager.getInputState(),e={x:t.mouse.x-window.innerWidth/2,y:t.mouse.y-window.innerHeight/2};this.cameraManager.updateStatic(e),this.headingEl&&(this.headingEl.style.transform=`translate(${e.x/100}px, ${e.y/100}px)`),this.selectEl&&(this.selectEl.style.transform=`translate(${e.x/200}px, ${e.y/200}px)`)}enter(t){this.blackoutEl&&(this.blackoutEl.classList.remove("left"),this.blackoutEl.classList.remove("right")),setTimeout(()=>{this.scene.remove(this.stand),this.mode=t,this.mode===Gt.FREEFLIGHT&&this.initGame()},1e3)}_updateActiveProjectiles(){const t=[],e=this.playerPlane.mesh,s=this.playerPlane.collider,n=this.playerPlane.getPosition();for(const o of this.activeProjectiles){o.updateMovement();let i=!1;o.owner!==e&&!this.crashed&&o.checkCollisionWith(s)&&(Hs(e,s,this.scene,this.cameraManager.getThreeCamera(),!0,this),i=!0),!i&&o.isOutOfBounds(n)&&(i=!0),i?o.removeFromScene(this.scene):t.push(o)}this.activeProjectiles=t}setCrashed(t){this.crashed=t,t&&this.soundManager.playExplosionSound()}getPlayerBySid(t){return this.players.find(e=>e.sid===t)}addPlayer(t){this.players.push(t)}removePlayer(t){this.players=this.players.filter(e=>e.sid!==t)}addShard(t){this.shards.push(t)}clearShards(){this.shards=[]}}const oo=new io;oo.initializeApp();
